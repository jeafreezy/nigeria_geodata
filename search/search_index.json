{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Nigeria Geodata","text":"<p>A Python library for fast and efficient access to geospatial data for Nigeria.</p> <p> </p> <p>Documentation: https://jeafreezy.github.io/nigeria_geodata/</p> <p>Source Code: https://github.com/jeafreezy/nigeria_geodata</p> <p>Nigeria Geodata is a fast and efficient Python client for accessing geospatial data for Nigeria.</p> <p>The key features are:</p> <ul> <li>High Performance: Offers exceptional speed with both synchronous and asynchronous support to cater to different use cases and performance needs</li> <li>Map Visualization: Provides smooth map visualization using the fast Lonboard library.</li> <li>Lightweight: Minimal dependencies\u2014just one required (httpx), with optional extras available for additional features.</li> <li>User-Friendly: Easy to use and learn; set up quickly with just a few lines of code.</li> <li>CLI Support: Intuitive command-line interface built with Typer.</li> <li>Real-Time Data: Fetches up-to-date data directly from the GRID3 database (more to come!), ensuring you always work with the latest information.</li> <li>Advanced Filtering: Allows for precise filtering based on state names (e.g FCT, Lagos), bounding boxes (bbox), and areas of interest (AOI).</li> </ul>"},{"location":"#dependency","title":"Dependency","text":"<p>nigeria_geodata depends on only one core package:</p> <ul> <li>Httpx - for the api requests.</li> </ul>"},{"location":"#additional-optional-dependencies","title":"Additional Optional Dependencies","text":"<p>There are some additional dependencies you might want to install.</p> <ul> <li>Typer - for cli support.</li> <li>Lonboard - for map visualization.</li> <li>Geopandas - to return the data as a geodataframe.</li> <li>Pandas - to return the data as a dataframe.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Create and activate a virtual environment and then install nigeria_geodata:</p> <p>To install the lightweight version using pip:</p> pip install nigeria-geodata <p>This version will return all the data as Python objects, mostly as a list, and list of dicts.</p> <p>To install it with <code>typer</code>, <code>lonboard</code> and <code>geopandas</code>:</p> pip install nigeria-geodata['standard'] <p>This version will allow you to get the data as a dataframe, geodataframe, or an interactive map.</p> pip install nigeria-geodata['cli'] <p>This version provides CLI support for the package. It is also lightweight -- It will return the data as pure Python objects.</p>"},{"location":"#get-started","title":"Get Started","text":"<p>For the simplest usecase, search for all the available health care data in Nigeria.</p> from nigeria_geodata import Grid3, AsyncGrid3# Syncsearch_results = Grid3().search(\"health\")print(search_results)# this will return a dataframe with all the available health care datasets.# Asyncsearch_results = await AsyncGrid3().search(\"health\")print(search_results)# this will return a dataframe with all the available health care datasets. <p>Under the hood, this makes an api request to the GRID3 database to get the datasets. Refer to the documentation and examples for more use cases.</p>"},{"location":"#acknowledgment","title":"Acknowledgment","text":"<p>In addition to the great libraries we're resting upon, we would also like to thank GRID3 for providing real-time and comprehensive geospatial data that powers this library.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license. See LICENSE.MD.</p>"},{"location":"benchmark/","title":"Async","text":"<p>Benchmarks the time taken for asynchronous data filtering using the AsyncGrid3 class.</p> <p>This function initializes an AsyncGrid3 instance, performs an asynchronous filter operation on a specific dataset (\"NGA_HealthFacilities_v1_72\") and state (\"abuja\"), and prints the time taken for this operation.</p> Example <p>await benchmark_async()</p> Note <p>The performance results will vary based on the dataset size and system specifications.</p> Source code in <code>nigeria_geodata/benchmark.py</code> <pre><code>async def benchmark_async():\n    \"\"\"\n    Benchmarks the time taken for asynchronous data filtering using the AsyncGrid3 class.\n\n    This function initializes an AsyncGrid3 instance, performs an asynchronous filter operation\n    on a specific dataset (\"NGA_HealthFacilities_v1_72\") and state (\"abuja\"), and\n    prints the time taken for this operation.\n\n    Example:\n        await benchmark_async()\n\n    Note:\n        The performance results will vary based on the dataset size and system specifications.\n    \"\"\"\n    grid3 = AsyncGrid3()\n    start_time = time.time()\n    await grid3.filter(\"NGA_HealthFacilities_v1_72\", \"abuja\")\n    elapsed_time = time.time() - start_time\n    print(f\"Asynchronous call took {elapsed_time:.2f} seconds\")\n</code></pre>"},{"location":"benchmark/#sync","title":"Sync","text":"<p>Benchmarks the time taken for synchronous data filtering using the Grid3 class.</p> <p>This function initializes a Grid3 instance, performs a synchronous filter operation on a specific dataset (\"NGA_HealthFacilities_v1_72\") and state (\"abuja\"), and prints the time taken for this operation.</p> Example <p>benchmark_sync()</p> Note <p>The performance results will vary based on the dataset size and system specifications.</p> Source code in <code>nigeria_geodata/benchmark.py</code> <pre><code>def benchmark_sync():\n    \"\"\"\n    Benchmarks the time taken for synchronous data filtering using the Grid3 class.\n\n    This function initializes a Grid3 instance, performs a synchronous filter operation\n    on a specific dataset (\"NGA_HealthFacilities_v1_72\") and state (\"abuja\"), and\n    prints the time taken for this operation.\n\n    Example:\n        benchmark_sync()\n\n    Note:\n        The performance results will vary based on the dataset size and system specifications.\n    \"\"\"\n    grid3 = Grid3()\n    start_time = time.time()\n    grid3.filter(\n        \"NGA_HealthFacilities_v1_72\",\n        \"abuja\",\n    )\n    elapsed_time = time.time() - start_time\n    print(f\"Synchronous call took {elapsed_time:.2f} seconds\")\n</code></pre>"},{"location":"benchmark/#results","title":"Results","text":"<ul> <li>sync took 4.58 seconds.</li> <li>async took 0.98 seconds.</li> <li>machine - MBP 16inch. M3, 36 GB RAM.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#v000-2024-08-24","title":"v0.0.0 - 2024-08-24","text":"<ul> <li>Initial release with core features. See documentation for more information.</li> </ul>"},{"location":"api/datasources/grid3/async/","title":"GRID3 Async","text":"<p>               Bases: <code>AsyncBaseDataSource</code></p> Source code in <code>nigeria_geodata/datasources/grid3.py</code> <pre><code>class AsyncGrid3(AsyncBaseDataSource):\n    def __init__(self):\n        self.sync_grid3 = Grid3()\n\n    async def _run_sync(self, func, *args, **kwargs):\n        loop = asyncio.get_running_loop()\n        return await loop.run_in_executor(None, func, *args, **kwargs)\n\n    async def list_data(\n        self, dataframe: bool = True\n    ) -&gt; Union[List[EsriFeatureServiceBasicInfo], Optional[\"pd.DataFrame\"]]:\n        return await self._run_sync(self.sync_grid3.list_data, dataframe)\n\n    async def search(\n        self, query: str, dataframe: bool = True\n    ) -&gt; Union[List[EsriFeatureServiceBasicInfo], List, Optional[\"pd.DataFrame\"]]:\n        return await self._run_sync(self.sync_grid3.search, query, dataframe)\n\n    async def filter(\n        self,\n        data_name: str,\n        state: Optional[str] = None,\n        bbox: Optional[List[float]] = None,\n        aoi_geometry: Geometry = None,\n        preview: bool = False,\n        geodataframe: bool = False,\n    ) -&gt; Union[\n        Optional[\"gpd.GeoDataFrame\"],\n        Optional[\"Map\"],\n        List[Dict[str, Any]],\n    ]:\n        return await self._run_sync(\n            self.sync_grid3.filter,\n            data_name,\n            state,\n            bbox,\n            aoi_geometry,\n            preview,\n            geodataframe,\n        )\n\n    async def info(\n        self, data_name: str, dataframe: bool = True\n    ) -&gt; Union[EsriFeatureLayerInfo, Optional[\"pd.DataFrame\"], Dict[str, Any]]:\n        return await self._run_sync(self.sync_grid3.info, data_name, dataframe)\n\n    def __repr__(self) -&gt; str:\n        return \"&lt;AsyncGrid3DataSource&gt;\"\n</code></pre>"},{"location":"api/datasources/grid3/sync/","title":"GRID3 Sync","text":"<p>               Bases: <code>SyncBaseDataSource</code></p> Source code in <code>nigeria_geodata/datasources/grid3.py</code> <pre><code>class Grid3(SyncBaseDataSource):\n    service_url: str = Config.get_service_url(DataSource.GRID3)\n    service_info_url: str = Config.get_service_info_url(DataSource.GRID3)\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        # fetch at initialization for optimal performance\n        self.feature_services = self._get_feature_services()\n\n    def _get_feature_services(self) -&gt; List[EsriFeatureServiceBasicInfo]:\n        \"\"\"\n        Retrieve the available feature services containing Nigeria data from the ArcGIS Server root directory.\n\n        This method fetches the feature services from the Grid3 server and filters out\n        those relevant to Nigeria, identified by either \"NGA\" or \"NIGERIA\" in the service name.\n\n        Returns:\n            List[EsriFeatureServiceBasicInfo]: A list of feature services with basic metadata\n                                               (name, URL, and type) relevant to Nigeria.\n        \"\"\"\n\n        api_response = make_request(self.service_url)\n\n        # based on review of the datasets, Nigeria is either represented as Nigeria or NGA\n        # For now it works, but this has a potential for improvement.\n        feature_services = list(\n            map(\n                lambda feature_service: EsriFeatureServiceBasicInfo(\n                    feature_service[\"name\"],\n                    feature_service[\"url\"],\n                    feature_service[\"type\"],\n                ),\n                filter(\n                    lambda response_obj: \"NGA\" in str(response_obj[\"name\"]).upper()\n                    or \"NIGERIA\" in str(response_obj[\"name\"]).upper(),\n                    api_response.get(\"services\", []),\n                ),\n            ),\n        )\n        self.feature_services = feature_services\n        return feature_services\n\n    def __find_and_validate_name(self, data_name) -&gt; List[EsriFeatureServiceBasicInfo]:\n        \"\"\"\n        Validate the existence of a dataset by name.\n\n        This method checks if a dataset with the given name exists within the available\n        Grid3 feature services. If it doesn't exist, it raises a ValueError.\n\n        Args:\n            data_name (str): The name of the dataset to search for.\n\n        Returns:\n            List[EsriFeatureServiceBasicInfo]: A list of matching feature services (if found).\n\n        Raises:\n            ValueError: If the provided data name does not exist in the Grid3 database.\n        \"\"\"\n        data_exist = [\n            service\n            for service in self.feature_services\n            if service.name.lower() == data_name.lower()\n        ]\n        if len(data_exist) == 0:\n            msg = f\"The provided data name '{data_name}' does not exist in the Grid3 database.\"\n            logger.error(msg)\n            raise ValueError(msg)\n        return data_exist\n\n    def __get_max_features(self, service_url: str) -&gt; int:\n        \"\"\"\n        Retrieve the maximum number of features available in a given feature service.\n\n        This method makes a request to the Grid3 server to count the number of features\n        in the dataset by performing a statistics query.\n\n        Args:\n            service_url (str): The URL of the feature service to query.\n\n        Returns:\n            int: The total number of features available in the dataset.\n        \"\"\"\n        params = {\n            \"where\": \"FID &gt; 0\",\n            \"groupByFieldsForStatistics\": \"\",\n            \"orderByFields\": \"\",\n            \"returnDistinctValues\": \"true\",\n            \"outStatistics\": [\n                [\n                    {\n                        \"statisticType\": \"count\",\n                        \"onStatisticField\": \"FID\",\n                        \"outStatisticFieldName\": \"COUNT\",\n                    }\n                ]\n            ],\n            \"f\": \"json\",\n        }\n        res = make_request(service_url, params=params)\n        return res[\"features\"][0][\"attributes\"][\"COUNT\"]\n\n    def list_data(\n        self, dataframe: bool = True\n    ) -&gt; Union[List[EsriFeatureServiceBasicInfo], Optional[\"pd.DataFrame\"]]:\n        \"\"\"\n        List available datasets from the Grid3 data source.\n\n        This method retrieves a list of all datasets available in the Grid3 data source.\n        It can return the information either as a list of `EsriFeatureServiceBasicInfo`\n        objects or as a pandas DataFrame, depending on the `dataframe` parameter.\n\n        Args:\n            dataframe (bool): If True, returns the information as a pandas DataFrame.\n                              If False, returns a list of `EsriFeatureServiceBasicInfo` objects.\n\n        Returns:\n            Union[List[EsriFeatureServiceBasicInfo], Optional[\"pd.DataFrame\"]]: A list of\n            `EsriFeatureServiceBasicInfo` objects or a pandas DataFrame containing dataset information.\n        \"\"\"\n        total_services = len(self.feature_services)\n        # Note: a feature server can have many layers, but inspecting the Grid3 service\n        # all the feature server have a single layer for a single dataset\n        # although the id of the layers are different.\n        logger.info(\n            f\"There is a total {total_services + 1} Nigeria geodata in the Grid3 database.\"\n        )\n        if dataframe:\n            pd = CheckDependencies.pandas()\n            data = {\n                \"id\": list(range(total_services)),\n                \"name\": [\n                    feature_service.name for feature_service in self.feature_services\n                ],\n            }\n            return pd.DataFrame(data)\n        # return a dict for those that don't want a dataframe or don't have pandas installed.\n        return [x.__dict__ for x in self.feature_services]\n\n    def search(\n        self, query: str, dataframe: bool = True\n    ) -&gt; Union[List[EsriFeatureServiceBasicInfo], List, Optional[\"pd.DataFrame\"]]:\n        \"\"\"\n        Search the Grid3 data source for datasets matching a query string.\n\n        This method searches for datasets whose names contain the specified query string.\n        It can return the search results as a list of `EsriFeatureServiceBasicInfo`\n        objects or as a pandas DataFrame, depending on the `dataframe` parameter.\n\n        Args:\n            query (str): The query string to search for in the dataset names.\n            dataframe (bool): If True, returns the search results as a pandas DataFrame.\n                              If False, returns a list of `EsriFeatureServiceBasicInfo` objects.\n\n        Returns:\n            Union[List[EsriFeatureServiceBasicInfo], List, Optional[\"pd.DataFrame\"]]: A list of\n            `EsriFeatureServiceBasicInfo` objects matching the query or a pandas DataFrame of results.\n        \"\"\"\n        search_results = list(\n            filter(\n                lambda feature_server: query.upper()\n                in str(feature_server.name).upper(),\n                self.feature_services,\n            ),\n        )\n\n        total_results = len(search_results)\n        logger.info(f\"Search query for '{query}' returned {total_results} results.\")\n\n        if len(search_results) &gt; 0:\n            if dataframe:\n                pd = CheckDependencies.pandas()\n                # they don't need to see the url when rendering the dataframe.\n                data = {\n                    \"id\": list(range(total_results)),\n                    \"name\": [\n                        feature_service.name for feature_service in search_results\n                    ],\n                }\n                return pd.DataFrame(data)\n\n            # return it as a list of dict\n            return [x.__dict__ for x in search_results]\n        print(\n            f\"Search query for '{query}' did not match any available datasets. Try another query or use `Grid3().list_data()` to see available datasets.\"\n        )\n        return []\n\n    def info(\n        self, data_name: str, dataframe: bool = True\n    ) -&gt; Union[EsriFeatureLayerInfo, Optional[\"pd.DataFrame\"], Dict[str, Any]]:\n        \"\"\"\n        Retrieve detailed information about a specific dataset from the Grid3 data source.\n\n        This method provides detailed information about a dataset, including metadata and\n        layer details, by connecting to the feature service. The information can be returned\n        as an `EsriFeatureLayerInfo` object or as a pandas DataFrame, depending on the\n        `dataframe` parameter.\n\n        Args:\n            data_name (str): The name of the dataset to retrieve information about.\n            dataframe (bool): If True, returns the information as a pandas DataFrame.\n                              If False, returns an `EsriFeatureLayerInfo` object.\n\n        Returns:\n            Union[EsriFeatureLayerInfo, Optional[\"pd.DataFrame\"], Dict[str, Any]]: Detailed\n            information about the dataset as an `EsriFeatureLayerInfo` object or a pandas DataFrame.\n        \"\"\"\n        search_result = self.__find_and_validate_name(data_name)\n\n        query_params = {\"f\": \"json\"}\n        # incase it returns multiple just use the first one.\n        feature_server = search_result[0]\n        response = make_request(f\"{feature_server.url}\", query_params)\n        # make a request to the actual layer to get the last edited date\n        layer_response = make_request(\n            f\"{feature_server.url}/{response['layers'][0]['id']}\", query_params\n        )\n        feature_service = EsriFeatureLayerInfo(\n            layerName=layer_response[\"name\"],\n            layerGeometryType=layer_response[\"geometryType\"],\n            layerObjectIdField=layer_response[\"objectIdField\"],\n            layerId=response[\"layers\"][0][\"id\"],\n            serviceDescription=response[\"serviceDescription\"],\n            serviceItemId=response[\"serviceItemId\"],\n            maxRecordCount=response[\"maxRecordCount\"],\n            supportedQueryFormats=response[\"supportedQueryFormats\"],\n            supportedExportFormats=response[\"supportedExportFormats\"],\n            capabilities=response[\"capabilities\"],\n            description=response[\"description\"],\n            copyrightText=response[\"copyrightText\"],\n            spatialReference=response[\"spatialReference\"],\n            fullExtent=response[\"fullExtent\"],\n            layers=response[\"layers\"],\n            tables=response[\"tables\"],\n            featureServerURL=feature_server.url,\n            layerLastUpdated=timestamp_to_datetime(\n                layer_response[\"editingInfo\"][\"dataLastEditDate\"]\n            ),\n            totalFeatures=self.__get_max_features(\n                f\"{feature_server.url}/{response['layers'][0]['id']}/query\"\n            ),\n        )\n        if dataframe:\n            pd = CheckDependencies.pandas()\n            data = feature_service.__dict__.copy()\n            transformed_data = {\"Key\": list(data.keys()), \"Value\": list(data.values())}\n            return pd.DataFrame(transformed_data)\n        return feature_service.__dict__\n\n    def filter(\n        self,\n        data_name: str,\n        state: Optional[str] = None,\n        bbox: Optional[List[float]] = None,\n        aoi_geometry: Geometry = None,\n        preview: bool = False,\n        geodataframe: bool = True,\n    ) -&gt; Union[\n        Optional[\"gpd.GeoDataFrame\"],\n        Optional[\"Map\"],\n        List[Dict[str, Any]],\n    ]:\n        \"\"\"\n        Filter datasets based on specified criteria and retrieve the results.\n\n        This method filters the dataset based on the provided state, bounding box (bbox),\n        or area of interest (aoi_geometry). It retrieves the filtered data and can return\n        it as a GeoDataFrame, a preview map, or as a list of feature dictionaries.\n\n        Args:\n            data_name (str): The name of the dataset to filter.\n            state (Optional[str]): The name of the Nigerian state to filter by (if applicable).\n            bbox (Optional[List[float]]): The bounding box to filter by, defined as [xmin, ymin, xmax, ymax].\n            aoi_geometry (Geometry): The area of interest geometry to filter by.\n            preview (bool): If True, returns a preview map of the filtered results.\n                            If False, returns the filtered data without a preview.\n            geodataframe (bool): If True, returns the filtered data as a GeoDataFrame.\n                                 If False, returns a list of feature dictionaries.\n\n        Returns:\n            Union[Optional[\"gpd.GeoDataFrame\"], Optional[\"Map\"], List[Dict[str, Any]]]:\n            The filtered dataset as a GeoDataFrame, a preview map, or a list of feature dictionaries.\n        \"\"\"\n        feature_service = self.info(data_name, False)\n\n        # only one parameter can be provided, so this check is to ensure that.\n        params = sum([state is not None, bbox is not None, aoi_geometry is not None])\n\n        if params &gt; 1:\n            raise ValueError(\n                \"Only one parameter (state, bbox, or aoi_geometry) can be provided.\"\n            )\n\n        # defaults\n        esri_geometry = None\n        geometryType = \"esriGeometryEnvelope\"  # default to the esriGeometryEnvelope which is like the bbox.\n\n        # State validation\n        if state:\n            valid_states = [x.value.lower() for x in NigeriaState]\n            if state.lower() not in valid_states:\n                raise ValueError(\n                    f\"The provided state '{state}' is not a valid Nigeria State. Available states are: {', '.join(valid_states)}\"\n                )\n            # update esri geometry\n            geometryType = \"esriGeometryPolygon\"\n            esri_geometry = GeodataUtils.geojson_to_esri_json(\n                GeodataUtils.get_state_geometry(state)\n            )\n\n        # bbox validation\n        if bbox:\n            if len(bbox) != 4 or not all(\n                isinstance(coord, (int, float)) for coord in bbox\n            ):\n                raise ValueError(\n                    \"The provided bbox is invalid. It should be a list of four numeric values.\"\n                )\n            # update esribbox\n            esri_geometry = bbox\n\n        if aoi_geometry:\n            if not GeodataUtils.validate_geojson_geometry(aoi_geometry):\n                raise ValueError(\"The provided aoi_geometry is invalid.\")\n\n            geometryType = GeodataUtils.geojson_to_esri_type(aoi_geometry[\"type\"])\n            esri_geometry = GeodataUtils.geojson_to_esri_json(aoi_geometry)\n\n        params = {\n            \"where\": f\"{feature_service['layerObjectIdField']} &gt; 0\",  # this is required\n            \"geometryType\": geometryType,\n            \"f\": \"geojson\",\n            \"outFields\": \"*\",  # to return all the attributes of the data\n            \"spatialRel\": \"esriSpatialRelIntersects\",\n        }\n\n        # update the params if the user filters by state or bbox\n        if esri_geometry:\n            if bbox:\n                params.update({\"geometry\": \",\".join(map(str, esri_geometry))})\n            if aoi_geometry or state:\n                params.update({\"geometry\": esri_geometry})\n\n        max_features = feature_service[\"totalFeatures\"]\n        if max_features == 0:\n            return []\n        result_list = []\n        resultOffset = 0\n        max_request = ceil(max_features / feature_service[\"maxRecordCount\"])\n        for _ in range(max_request):\n            params[\"resultOffset\"] = resultOffset\n            response = make_request(\n                f\"{feature_service['featureServerURL']}/{feature_service['layerId']}/query\",\n                params=params,\n                method=RequestMethod.POST,\n            )\n            features = response[\"features\"]\n            result_list.extend(features)\n            resultOffset += feature_service[\"maxRecordCount\"]\n            # check the length of the response, if it's less than the maxRecordCount then we can break\n            # e.g when filtering, the result might not be up to 2000 i.e the maxRecordCount, so instead of making multiple requests\n            # based on the total dataset i.e max_features, we can break it here.\n            # an alternative is to hit the statistics endpoint with the filtering to get the maximum features for the query\n            # but that's going to be another query. So this approach works fine for now.\n            # Will require more testing.\n            if len(features) &lt; feature_service[\"maxRecordCount\"]:\n                break\n\n        if geodataframe or preview:\n            if len(result_list) &gt; 0:\n                gpd = CheckDependencies.geopandas()\n                gdf = gpd.GeoDataFrame.from_features(\n                    result_list,\n                    crs=f\"EPSG:{feature_service['spatialReference']['wkid']}\",\n                )\n                if preview:\n                    viz = CheckDependencies.lonboard()\n                    return viz(gdf)\n                # otherwise return the gdf\n                return gdf\n        return result_list\n\n    def __repr__(self) -&gt; str:\n        return \"&lt;Grid3DataSource}&gt;\"\n</code></pre>"},{"location":"api/datasources/grid3/sync/#nigeria_geodata.datasources.grid3.Grid3.__find_and_validate_name","title":"<code>__find_and_validate_name(data_name)</code>","text":"<p>Validate the existence of a dataset by name.</p> <p>This method checks if a dataset with the given name exists within the available Grid3 feature services. If it doesn't exist, it raises a ValueError.</p> <p>Parameters:</p> Name Type Description Default <code>data_name</code> <code>str</code> <p>The name of the dataset to search for.</p> required <p>Returns:</p> Type Description <code>List[EsriFeatureServiceBasicInfo]</code> <p>List[EsriFeatureServiceBasicInfo]: A list of matching feature services (if found).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided data name does not exist in the Grid3 database.</p> Source code in <code>nigeria_geodata/datasources/grid3.py</code> <pre><code>def __find_and_validate_name(self, data_name) -&gt; List[EsriFeatureServiceBasicInfo]:\n    \"\"\"\n    Validate the existence of a dataset by name.\n\n    This method checks if a dataset with the given name exists within the available\n    Grid3 feature services. If it doesn't exist, it raises a ValueError.\n\n    Args:\n        data_name (str): The name of the dataset to search for.\n\n    Returns:\n        List[EsriFeatureServiceBasicInfo]: A list of matching feature services (if found).\n\n    Raises:\n        ValueError: If the provided data name does not exist in the Grid3 database.\n    \"\"\"\n    data_exist = [\n        service\n        for service in self.feature_services\n        if service.name.lower() == data_name.lower()\n    ]\n    if len(data_exist) == 0:\n        msg = f\"The provided data name '{data_name}' does not exist in the Grid3 database.\"\n        logger.error(msg)\n        raise ValueError(msg)\n    return data_exist\n</code></pre>"},{"location":"api/datasources/grid3/sync/#nigeria_geodata.datasources.grid3.Grid3.__get_max_features","title":"<code>__get_max_features(service_url)</code>","text":"<p>Retrieve the maximum number of features available in a given feature service.</p> <p>This method makes a request to the Grid3 server to count the number of features in the dataset by performing a statistics query.</p> <p>Parameters:</p> Name Type Description Default <code>service_url</code> <code>str</code> <p>The URL of the feature service to query.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The total number of features available in the dataset.</p> Source code in <code>nigeria_geodata/datasources/grid3.py</code> <pre><code>def __get_max_features(self, service_url: str) -&gt; int:\n    \"\"\"\n    Retrieve the maximum number of features available in a given feature service.\n\n    This method makes a request to the Grid3 server to count the number of features\n    in the dataset by performing a statistics query.\n\n    Args:\n        service_url (str): The URL of the feature service to query.\n\n    Returns:\n        int: The total number of features available in the dataset.\n    \"\"\"\n    params = {\n        \"where\": \"FID &gt; 0\",\n        \"groupByFieldsForStatistics\": \"\",\n        \"orderByFields\": \"\",\n        \"returnDistinctValues\": \"true\",\n        \"outStatistics\": [\n            [\n                {\n                    \"statisticType\": \"count\",\n                    \"onStatisticField\": \"FID\",\n                    \"outStatisticFieldName\": \"COUNT\",\n                }\n            ]\n        ],\n        \"f\": \"json\",\n    }\n    res = make_request(service_url, params=params)\n    return res[\"features\"][0][\"attributes\"][\"COUNT\"]\n</code></pre>"},{"location":"api/datasources/grid3/sync/#nigeria_geodata.datasources.grid3.Grid3.filter","title":"<code>filter(data_name, state=None, bbox=None, aoi_geometry=None, preview=False, geodataframe=True)</code>","text":"<p>Filter datasets based on specified criteria and retrieve the results.</p> <p>This method filters the dataset based on the provided state, bounding box (bbox), or area of interest (aoi_geometry). It retrieves the filtered data and can return it as a GeoDataFrame, a preview map, or as a list of feature dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>data_name</code> <code>str</code> <p>The name of the dataset to filter.</p> required <code>state</code> <code>Optional[str]</code> <p>The name of the Nigerian state to filter by (if applicable).</p> <code>None</code> <code>bbox</code> <code>Optional[List[float]]</code> <p>The bounding box to filter by, defined as [xmin, ymin, xmax, ymax].</p> <code>None</code> <code>aoi_geometry</code> <code>Geometry</code> <p>The area of interest geometry to filter by.</p> <code>None</code> <code>preview</code> <code>bool</code> <p>If True, returns a preview map of the filtered results.             If False, returns the filtered data without a preview.</p> <code>False</code> <code>geodataframe</code> <code>bool</code> <p>If True, returns the filtered data as a GeoDataFrame.                  If False, returns a list of feature dictionaries.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[Optional[GeoDataFrame], Optional[Map], List[Dict[str, Any]]]</code> <p>Union[Optional[\"gpd.GeoDataFrame\"], Optional[\"Map\"], List[Dict[str, Any]]]:</p> <code>Union[Optional[GeoDataFrame], Optional[Map], List[Dict[str, Any]]]</code> <p>The filtered dataset as a GeoDataFrame, a preview map, or a list of feature dictionaries.</p> Source code in <code>nigeria_geodata/datasources/grid3.py</code> <pre><code>def filter(\n    self,\n    data_name: str,\n    state: Optional[str] = None,\n    bbox: Optional[List[float]] = None,\n    aoi_geometry: Geometry = None,\n    preview: bool = False,\n    geodataframe: bool = True,\n) -&gt; Union[\n    Optional[\"gpd.GeoDataFrame\"],\n    Optional[\"Map\"],\n    List[Dict[str, Any]],\n]:\n    \"\"\"\n    Filter datasets based on specified criteria and retrieve the results.\n\n    This method filters the dataset based on the provided state, bounding box (bbox),\n    or area of interest (aoi_geometry). It retrieves the filtered data and can return\n    it as a GeoDataFrame, a preview map, or as a list of feature dictionaries.\n\n    Args:\n        data_name (str): The name of the dataset to filter.\n        state (Optional[str]): The name of the Nigerian state to filter by (if applicable).\n        bbox (Optional[List[float]]): The bounding box to filter by, defined as [xmin, ymin, xmax, ymax].\n        aoi_geometry (Geometry): The area of interest geometry to filter by.\n        preview (bool): If True, returns a preview map of the filtered results.\n                        If False, returns the filtered data without a preview.\n        geodataframe (bool): If True, returns the filtered data as a GeoDataFrame.\n                             If False, returns a list of feature dictionaries.\n\n    Returns:\n        Union[Optional[\"gpd.GeoDataFrame\"], Optional[\"Map\"], List[Dict[str, Any]]]:\n        The filtered dataset as a GeoDataFrame, a preview map, or a list of feature dictionaries.\n    \"\"\"\n    feature_service = self.info(data_name, False)\n\n    # only one parameter can be provided, so this check is to ensure that.\n    params = sum([state is not None, bbox is not None, aoi_geometry is not None])\n\n    if params &gt; 1:\n        raise ValueError(\n            \"Only one parameter (state, bbox, or aoi_geometry) can be provided.\"\n        )\n\n    # defaults\n    esri_geometry = None\n    geometryType = \"esriGeometryEnvelope\"  # default to the esriGeometryEnvelope which is like the bbox.\n\n    # State validation\n    if state:\n        valid_states = [x.value.lower() for x in NigeriaState]\n        if state.lower() not in valid_states:\n            raise ValueError(\n                f\"The provided state '{state}' is not a valid Nigeria State. Available states are: {', '.join(valid_states)}\"\n            )\n        # update esri geometry\n        geometryType = \"esriGeometryPolygon\"\n        esri_geometry = GeodataUtils.geojson_to_esri_json(\n            GeodataUtils.get_state_geometry(state)\n        )\n\n    # bbox validation\n    if bbox:\n        if len(bbox) != 4 or not all(\n            isinstance(coord, (int, float)) for coord in bbox\n        ):\n            raise ValueError(\n                \"The provided bbox is invalid. It should be a list of four numeric values.\"\n            )\n        # update esribbox\n        esri_geometry = bbox\n\n    if aoi_geometry:\n        if not GeodataUtils.validate_geojson_geometry(aoi_geometry):\n            raise ValueError(\"The provided aoi_geometry is invalid.\")\n\n        geometryType = GeodataUtils.geojson_to_esri_type(aoi_geometry[\"type\"])\n        esri_geometry = GeodataUtils.geojson_to_esri_json(aoi_geometry)\n\n    params = {\n        \"where\": f\"{feature_service['layerObjectIdField']} &gt; 0\",  # this is required\n        \"geometryType\": geometryType,\n        \"f\": \"geojson\",\n        \"outFields\": \"*\",  # to return all the attributes of the data\n        \"spatialRel\": \"esriSpatialRelIntersects\",\n    }\n\n    # update the params if the user filters by state or bbox\n    if esri_geometry:\n        if bbox:\n            params.update({\"geometry\": \",\".join(map(str, esri_geometry))})\n        if aoi_geometry or state:\n            params.update({\"geometry\": esri_geometry})\n\n    max_features = feature_service[\"totalFeatures\"]\n    if max_features == 0:\n        return []\n    result_list = []\n    resultOffset = 0\n    max_request = ceil(max_features / feature_service[\"maxRecordCount\"])\n    for _ in range(max_request):\n        params[\"resultOffset\"] = resultOffset\n        response = make_request(\n            f\"{feature_service['featureServerURL']}/{feature_service['layerId']}/query\",\n            params=params,\n            method=RequestMethod.POST,\n        )\n        features = response[\"features\"]\n        result_list.extend(features)\n        resultOffset += feature_service[\"maxRecordCount\"]\n        # check the length of the response, if it's less than the maxRecordCount then we can break\n        # e.g when filtering, the result might not be up to 2000 i.e the maxRecordCount, so instead of making multiple requests\n        # based on the total dataset i.e max_features, we can break it here.\n        # an alternative is to hit the statistics endpoint with the filtering to get the maximum features for the query\n        # but that's going to be another query. So this approach works fine for now.\n        # Will require more testing.\n        if len(features) &lt; feature_service[\"maxRecordCount\"]:\n            break\n\n    if geodataframe or preview:\n        if len(result_list) &gt; 0:\n            gpd = CheckDependencies.geopandas()\n            gdf = gpd.GeoDataFrame.from_features(\n                result_list,\n                crs=f\"EPSG:{feature_service['spatialReference']['wkid']}\",\n            )\n            if preview:\n                viz = CheckDependencies.lonboard()\n                return viz(gdf)\n            # otherwise return the gdf\n            return gdf\n    return result_list\n</code></pre>"},{"location":"api/datasources/grid3/sync/#nigeria_geodata.datasources.grid3.Grid3.info","title":"<code>info(data_name, dataframe=True)</code>","text":"<p>Retrieve detailed information about a specific dataset from the Grid3 data source.</p> <p>This method provides detailed information about a dataset, including metadata and layer details, by connecting to the feature service. The information can be returned as an <code>EsriFeatureLayerInfo</code> object or as a pandas DataFrame, depending on the <code>dataframe</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>data_name</code> <code>str</code> <p>The name of the dataset to retrieve information about.</p> required <code>dataframe</code> <code>bool</code> <p>If True, returns the information as a pandas DataFrame.               If False, returns an <code>EsriFeatureLayerInfo</code> object.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[EsriFeatureLayerInfo, Optional[DataFrame], Dict[str, Any]]</code> <p>Union[EsriFeatureLayerInfo, Optional[\"pd.DataFrame\"], Dict[str, Any]]: Detailed</p> <code>Union[EsriFeatureLayerInfo, Optional[DataFrame], Dict[str, Any]]</code> <p>information about the dataset as an <code>EsriFeatureLayerInfo</code> object or a pandas DataFrame.</p> Source code in <code>nigeria_geodata/datasources/grid3.py</code> <pre><code>def info(\n    self, data_name: str, dataframe: bool = True\n) -&gt; Union[EsriFeatureLayerInfo, Optional[\"pd.DataFrame\"], Dict[str, Any]]:\n    \"\"\"\n    Retrieve detailed information about a specific dataset from the Grid3 data source.\n\n    This method provides detailed information about a dataset, including metadata and\n    layer details, by connecting to the feature service. The information can be returned\n    as an `EsriFeatureLayerInfo` object or as a pandas DataFrame, depending on the\n    `dataframe` parameter.\n\n    Args:\n        data_name (str): The name of the dataset to retrieve information about.\n        dataframe (bool): If True, returns the information as a pandas DataFrame.\n                          If False, returns an `EsriFeatureLayerInfo` object.\n\n    Returns:\n        Union[EsriFeatureLayerInfo, Optional[\"pd.DataFrame\"], Dict[str, Any]]: Detailed\n        information about the dataset as an `EsriFeatureLayerInfo` object or a pandas DataFrame.\n    \"\"\"\n    search_result = self.__find_and_validate_name(data_name)\n\n    query_params = {\"f\": \"json\"}\n    # incase it returns multiple just use the first one.\n    feature_server = search_result[0]\n    response = make_request(f\"{feature_server.url}\", query_params)\n    # make a request to the actual layer to get the last edited date\n    layer_response = make_request(\n        f\"{feature_server.url}/{response['layers'][0]['id']}\", query_params\n    )\n    feature_service = EsriFeatureLayerInfo(\n        layerName=layer_response[\"name\"],\n        layerGeometryType=layer_response[\"geometryType\"],\n        layerObjectIdField=layer_response[\"objectIdField\"],\n        layerId=response[\"layers\"][0][\"id\"],\n        serviceDescription=response[\"serviceDescription\"],\n        serviceItemId=response[\"serviceItemId\"],\n        maxRecordCount=response[\"maxRecordCount\"],\n        supportedQueryFormats=response[\"supportedQueryFormats\"],\n        supportedExportFormats=response[\"supportedExportFormats\"],\n        capabilities=response[\"capabilities\"],\n        description=response[\"description\"],\n        copyrightText=response[\"copyrightText\"],\n        spatialReference=response[\"spatialReference\"],\n        fullExtent=response[\"fullExtent\"],\n        layers=response[\"layers\"],\n        tables=response[\"tables\"],\n        featureServerURL=feature_server.url,\n        layerLastUpdated=timestamp_to_datetime(\n            layer_response[\"editingInfo\"][\"dataLastEditDate\"]\n        ),\n        totalFeatures=self.__get_max_features(\n            f\"{feature_server.url}/{response['layers'][0]['id']}/query\"\n        ),\n    )\n    if dataframe:\n        pd = CheckDependencies.pandas()\n        data = feature_service.__dict__.copy()\n        transformed_data = {\"Key\": list(data.keys()), \"Value\": list(data.values())}\n        return pd.DataFrame(transformed_data)\n    return feature_service.__dict__\n</code></pre>"},{"location":"api/datasources/grid3/sync/#nigeria_geodata.datasources.grid3.Grid3.list_data","title":"<code>list_data(dataframe=True)</code>","text":"<p>List available datasets from the Grid3 data source.</p> <p>This method retrieves a list of all datasets available in the Grid3 data source. It can return the information either as a list of <code>EsriFeatureServiceBasicInfo</code> objects or as a pandas DataFrame, depending on the <code>dataframe</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>dataframe</code> <code>bool</code> <p>If True, returns the information as a pandas DataFrame.               If False, returns a list of <code>EsriFeatureServiceBasicInfo</code> objects.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[List[EsriFeatureServiceBasicInfo], Optional[DataFrame]]</code> <p>Union[List[EsriFeatureServiceBasicInfo], Optional[\"pd.DataFrame\"]]: A list of</p> <code>Union[List[EsriFeatureServiceBasicInfo], Optional[DataFrame]]</code> <p><code>EsriFeatureServiceBasicInfo</code> objects or a pandas DataFrame containing dataset information.</p> Source code in <code>nigeria_geodata/datasources/grid3.py</code> <pre><code>def list_data(\n    self, dataframe: bool = True\n) -&gt; Union[List[EsriFeatureServiceBasicInfo], Optional[\"pd.DataFrame\"]]:\n    \"\"\"\n    List available datasets from the Grid3 data source.\n\n    This method retrieves a list of all datasets available in the Grid3 data source.\n    It can return the information either as a list of `EsriFeatureServiceBasicInfo`\n    objects or as a pandas DataFrame, depending on the `dataframe` parameter.\n\n    Args:\n        dataframe (bool): If True, returns the information as a pandas DataFrame.\n                          If False, returns a list of `EsriFeatureServiceBasicInfo` objects.\n\n    Returns:\n        Union[List[EsriFeatureServiceBasicInfo], Optional[\"pd.DataFrame\"]]: A list of\n        `EsriFeatureServiceBasicInfo` objects or a pandas DataFrame containing dataset information.\n    \"\"\"\n    total_services = len(self.feature_services)\n    # Note: a feature server can have many layers, but inspecting the Grid3 service\n    # all the feature server have a single layer for a single dataset\n    # although the id of the layers are different.\n    logger.info(\n        f\"There is a total {total_services + 1} Nigeria geodata in the Grid3 database.\"\n    )\n    if dataframe:\n        pd = CheckDependencies.pandas()\n        data = {\n            \"id\": list(range(total_services)),\n            \"name\": [\n                feature_service.name for feature_service in self.feature_services\n            ],\n        }\n        return pd.DataFrame(data)\n    # return a dict for those that don't want a dataframe or don't have pandas installed.\n    return [x.__dict__ for x in self.feature_services]\n</code></pre>"},{"location":"api/datasources/grid3/sync/#nigeria_geodata.datasources.grid3.Grid3.search","title":"<code>search(query, dataframe=True)</code>","text":"<p>Search the Grid3 data source for datasets matching a query string.</p> <p>This method searches for datasets whose names contain the specified query string. It can return the search results as a list of <code>EsriFeatureServiceBasicInfo</code> objects or as a pandas DataFrame, depending on the <code>dataframe</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query string to search for in the dataset names.</p> required <code>dataframe</code> <code>bool</code> <p>If True, returns the search results as a pandas DataFrame.               If False, returns a list of <code>EsriFeatureServiceBasicInfo</code> objects.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[List[EsriFeatureServiceBasicInfo], List, Optional[DataFrame]]</code> <p>Union[List[EsriFeatureServiceBasicInfo], List, Optional[\"pd.DataFrame\"]]: A list of</p> <code>Union[List[EsriFeatureServiceBasicInfo], List, Optional[DataFrame]]</code> <p><code>EsriFeatureServiceBasicInfo</code> objects matching the query or a pandas DataFrame of results.</p> Source code in <code>nigeria_geodata/datasources/grid3.py</code> <pre><code>def search(\n    self, query: str, dataframe: bool = True\n) -&gt; Union[List[EsriFeatureServiceBasicInfo], List, Optional[\"pd.DataFrame\"]]:\n    \"\"\"\n    Search the Grid3 data source for datasets matching a query string.\n\n    This method searches for datasets whose names contain the specified query string.\n    It can return the search results as a list of `EsriFeatureServiceBasicInfo`\n    objects or as a pandas DataFrame, depending on the `dataframe` parameter.\n\n    Args:\n        query (str): The query string to search for in the dataset names.\n        dataframe (bool): If True, returns the search results as a pandas DataFrame.\n                          If False, returns a list of `EsriFeatureServiceBasicInfo` objects.\n\n    Returns:\n        Union[List[EsriFeatureServiceBasicInfo], List, Optional[\"pd.DataFrame\"]]: A list of\n        `EsriFeatureServiceBasicInfo` objects matching the query or a pandas DataFrame of results.\n    \"\"\"\n    search_results = list(\n        filter(\n            lambda feature_server: query.upper()\n            in str(feature_server.name).upper(),\n            self.feature_services,\n        ),\n    )\n\n    total_results = len(search_results)\n    logger.info(f\"Search query for '{query}' returned {total_results} results.\")\n\n    if len(search_results) &gt; 0:\n        if dataframe:\n            pd = CheckDependencies.pandas()\n            # they don't need to see the url when rendering the dataframe.\n            data = {\n                \"id\": list(range(total_results)),\n                \"name\": [\n                    feature_service.name for feature_service in search_results\n                ],\n            }\n            return pd.DataFrame(data)\n\n        # return it as a list of dict\n        return [x.__dict__ for x in search_results]\n    print(\n        f\"Search query for '{query}' did not match any available datasets. Try another query or use `Grid3().list_data()` to see available datasets.\"\n    )\n    return []\n</code></pre>"},{"location":"api/utils/enums/","title":"Nigeria State Names","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration for Nigerian states and the Federal Capital Territory (FCT).</p> <p>This class defines all the states and the Federal Capital Territory (FCT) in Nigeria. Each value corresponds to the official name of the state or territory.</p> Source code in <code>nigeria_geodata/utils/enums.py</code> <pre><code>class NigeriaState(Enum):\n    \"\"\"\n    Enumeration for Nigerian states and the Federal Capital Territory (FCT).\n\n    This class defines all the states and the Federal Capital Territory (FCT) in Nigeria.\n    Each value corresponds to the official name of the state or territory.\n    \"\"\"\n\n    ABIA = \"Abia\"\n    ADAMAWA = \"Adamawa\"\n    AKWA_IBOM = \"Akwa Ibom\"\n    ANAMBRA = \"Anambra\"\n    BAUCHI = \"Bauchi\"\n    BAYELSA = \"Bayelsa\"\n    BENUE = \"Benue\"\n    BORNO = \"Borno\"\n    CROSS_RIVER = \"Cross River\"\n    DELTA = \"Delta\"\n    EBONYI = \"Ebonyi\"\n    EDO = \"Edo\"\n    EKITI = \"Ekiti\"\n    ENUGU = \"Enugu\"\n    GOMBE = \"Gombe\"\n    IMO = \"Imo\"\n    JIGAWA = \"Jigawa\"\n    KADUNA = \"Kaduna\"\n    KANO = \"Kano\"\n    KATSINA = \"Katsina\"\n    KEBBI = \"Kebbi\"\n    KOGI = \"Kogi\"\n    KWARA = \"Kwara\"\n    LAGOS = \"Lagos\"\n    NASARAWA = \"Nasarawa\"\n    NIGER = \"Niger\"\n    OGUN = \"Ogun\"\n    ONDO = \"Ondo\"\n    OSUN = \"Osun\"\n    OYO = \"Oyo\"\n    PLATEAU = \"Plateau\"\n    RIVERS = \"Rivers\"\n    SOKOTO = \"Sokoto\"\n    TARABA = \"Taraba\"\n    YOBE = \"Yobe\"\n    ZAMFARA = \"Zamfara\"\n    FCT = \"Abuja\"  # Abuja is the name used in the data, but the user must provide FCT\n</code></pre>"},{"location":"api/utils/exceptions/","title":"Exceptions","text":"<p>Exceptions for the nigeria_geodata Package</p> <p>This module defines custom exceptions used within the <code>nigeria_geodata</code> package. These exceptions provide more specific error handling for various failure scenarios that can occur during operations related to geospatial data processing and interactions.</p> Authors <p>Emmanuel Jolaiya Samuel Adedoyin</p> Date <p>24/08/2024</p> <p>Raises:</p> Type Description <code>NigeriaGeodataError</code> <p>Base exception for all exceptions in the nigeria_geodata package.</p> <code>RequestError</code> <p>Raised for errors encountered during HTTP requests.</p> <code>HTTPStatusError</code> <p>Raised for HTTP status-related errors.</p> <code>JSONDecodeError</code> <p>Raised for errors encountered while decoding JSON data.</p> <code>PackageNotFoundError</code> <p>Raised when a required package is not found.</p>"},{"location":"api/utils/exceptions/#nigeria_geodata.utils.exceptions.HTTPStatusError","title":"<code>HTTPStatusError</code>","text":"<p>               Bases: <code>NigeriaGeodataError</code></p> <p>Exception raised for HTTP status errors.</p> <p>This exception is used when the server returns an HTTP status code that indicates an error (e.g., 4xx or 5xx codes). It helps to differentiate between successful and unsuccessful HTTP responses.</p> Source code in <code>nigeria_geodata/utils/exceptions.py</code> <pre><code>class HTTPStatusError(NigeriaGeodataError):\n    \"\"\"Exception raised for HTTP status errors.\n\n    This exception is used when the server returns an HTTP status code that indicates\n    an error (e.g., 4xx or 5xx codes). It helps to differentiate between successful\n    and unsuccessful HTTP responses.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/utils/exceptions/#nigeria_geodata.utils.exceptions.JSONDecodeError","title":"<code>JSONDecodeError</code>","text":"<p>               Bases: <code>NigeriaGeodataError</code></p> <p>Exception raised for JSON decoding errors.</p> <p>This exception is raised when there are issues decoding JSON data. It may be caused by malformed JSON, unexpected data formats, or other issues related to JSON processing.</p> Source code in <code>nigeria_geodata/utils/exceptions.py</code> <pre><code>class JSONDecodeError(NigeriaGeodataError):\n    \"\"\"Exception raised for JSON decoding errors.\n\n    This exception is raised when there are issues decoding JSON data. It may be caused\n    by malformed JSON, unexpected data formats, or other issues related to JSON processing.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/utils/exceptions/#nigeria_geodata.utils.exceptions.NigeriaGeodataError","title":"<code>NigeriaGeodataError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all nigeria_geodata errors.</p> Source code in <code>nigeria_geodata/utils/exceptions.py</code> <pre><code>class NigeriaGeodataError(Exception):\n    \"\"\"Base exception for all nigeria_geodata errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/utils/exceptions/#nigeria_geodata.utils.exceptions.PackageNotFoundError","title":"<code>PackageNotFoundError</code>","text":"<p>               Bases: <code>ModuleNotFoundError</code></p> <p>Exception raised when required packages are not found.</p> <p>This exception is raised when a required third-party package or module is not found or not installed. It helps in identifying and handling missing dependencies.</p> Source code in <code>nigeria_geodata/utils/exceptions.py</code> <pre><code>class PackageNotFoundError(ModuleNotFoundError):\n    \"\"\"Exception raised when required packages are not found.\n\n    This exception is raised when a required third-party package or module is not found\n    or not installed. It helps in identifying and handling missing dependencies.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/utils/exceptions/#nigeria_geodata.utils.exceptions.RequestError","title":"<code>RequestError</code>","text":"<p>               Bases: <code>NigeriaGeodataError</code></p> <p>Exception raised for errors during the request.</p> <p>This exception is used to indicate problems that occur during the process of making requests to data sources. It may be raised due to network issues, invalid request parameters, or other request-related failures.</p> Source code in <code>nigeria_geodata/utils/exceptions.py</code> <pre><code>class RequestError(NigeriaGeodataError):\n    \"\"\"Exception raised for errors during the request.\n\n    This exception is used to indicate problems that occur during the process\n    of making requests to data sources. It may be raised due to network issues,\n    invalid request parameters, or other request-related failures.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/utils/logging/","title":"Logging","text":"<p>Logging Configuration Module</p> <p>This module provides a centralized logging configuration for the nigeria_geodata package. It sets up a logger with a default warning level and a console handler to format and display log messages.</p> Authors <p>Emmanuel Jolaiya Samuel Adedoyin</p> Date <p>24/08/2024</p> <p>The logger is configured to output messages to the console with the following format: \"nigeria_geodata:%(asctime)s - %(name)s - %(levelname)s - %(message)s\"</p> <p>Functions: - configure_logging: Allows for customization of the logging level.</p> Usage <p>To use the logging configuration, import this module and call the <code>configure_logging</code> function to adjust the logging level as needed. The logger will automatically use the configured level and format for log messages.</p> <p>Example:     from nigeria_geodata.utils import configure_logging</p> <pre><code># Set the logging level to DEBUG\nlogger_module.configure_logging(logging.DEBUG)\n</code></pre>"},{"location":"api/utils/logging/#nigeria_geodata.utils.logger.configure_logging","title":"<code>configure_logging(level=logging.WARNING)</code>","text":"<p>Configure the logging level for the package.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Logging level (e.g., logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR)</p> <code>WARNING</code> Example Source code in <code>nigeria_geodata/utils/logger.py</code> <pre><code>def configure_logging(level=logging.WARNING):\n    \"\"\"\n    Configure the logging level for the package.\n\n    Args:\n        level (int): Logging level (e.g., logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR)\n\n    Example:\n        # Set logging level to INFO\n        configure_logging(logging.INFO)\n    \"\"\"\n    logger.setLevel(level)\n    for handler in logger.handlers:\n        handler.setLevel(level)\n</code></pre>"},{"location":"api/utils/logging/#nigeria_geodata.utils.logger.configure_logging--set-logging-level-to-info","title":"Set logging level to INFO","text":"<p>configure_logging(logging.INFO)</p>"},{"location":"cli/","title":"CLI","text":"<p>Usage:</p> <pre><code>$ [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <ul> <li><code>--install-completion</code>: Install completion for the current shell.</li> <li><code>--show-completion</code>: Show completion for the current shell, to copy it or customize the installation.</li> <li><code>--help</code>: Show this message and exit.</li> </ul> <p>Commands:</p> <ul> <li><code>async-grid3</code></li> <li><code>docs</code>: Launches the documentation website.</li> <li><code>grid3</code></li> </ul>"},{"location":"cli/#async-grid3","title":"<code>async-grid3</code>","text":"<p>Usage:</p> <pre><code>$ async-grid3 [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <ul> <li><code>--help</code>: Show this message and exit.</li> </ul> <p>Commands:</p> <ul> <li><code>filter</code>: Asynchronously filters data from the GRID3...</li> <li><code>info</code>: Asynchronously retrieves information about...</li> <li><code>list-data</code>: Asynchronously lists the available...</li> <li><code>search</code>: Asynchronously searches for data from the...</li> </ul>"},{"location":"cli/#async-grid3-filter","title":"<code>async-grid3 filter</code>","text":"<p>Asynchronously filters data from the GRID3 database.</p> <p>Args:     data_name (str): The name of the data to filter.     state (str, optional): The name of the state to filter for.     bbox (str, optional): The bounding box to filter with.     aoi_geometry (str, optional): The area of interest as a GeoJSON geometry string.     table (bool): If True, renders results as a table; otherwise, prints the results directly.</p> <p>Usage:</p> <pre><code>$ async-grid3 filter [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--data-name TEXT</code>: The name of the data to filter. e.g --data-name Nigeria_Health...  [required]</li> <li><code>--state TEXT</code>: The name of the state to filter for. Any from ['ABIA', 'ADAMAWA', 'AKWA_IBOM', 'ANAMBRA', 'BAUCHI', 'BAYELSA', 'BENUE', 'BORNO', 'CROSS_RIVER', 'DELTA', 'EBONYI', 'EDO', 'EKITI', 'ENUGU', 'GOMBE', 'IMO', 'JIGAWA', 'KADUNA', 'KANO', 'KATSINA', 'KEBBI', 'KOGI', 'KWARA', 'LAGOS', 'NASARAWA', 'NIGER', 'OGUN', 'ONDO', 'OSUN', 'OYO', 'PLATEAU', 'RIVERS', 'SOKOTO', 'TARABA', 'YOBE', 'ZAMFARA', 'FCT'] e.g --data-name abuja.</li> <li><code>--bbox TEXT</code>: The bounding box to filter with i.e 'min_x, min_y, max_x, max_y'. e.g --bbox '20.0, 12.3, 21.4, 34.5'.</li> <li><code>--aoi-geometry TEXT</code>: The aoi as a GeoJSON geometry string e.g --aoi-geometry '{'type': 'Point', 'coordinates': [30, 10]}'</li> <li><code>--table / --no-table</code>: If to render results as a table or not. Use --table to enable table (default) or --notable to disable table.  [default: table]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"cli/#async-grid3-info","title":"<code>async-grid3 info</code>","text":"<p>Asynchronously retrieves information about a specific dataset from the GRID3 database.</p> <p>Args:     data_name (str): The name of the data to get information on.</p> <p>Usage:</p> <pre><code>$ async-grid3 info [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--data-name TEXT</code>: The name of the data to get information on. e.g --data-name Nigeria_Health...  [required]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"cli/#async-grid3-list-data","title":"<code>async-grid3 list-data</code>","text":"<p>Asynchronously lists the available datasets for Nigeria from the GRID3 database.</p> <p>Args:     table (bool): If True, renders results as a table; otherwise, prints the results directly.</p> <p>Usage:</p> <pre><code>$ async-grid3 list-data [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--table / --no-table</code>: If to render results as a table or not. Use --table to enable table (default) or --notable to disable table.  [default: table]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"cli/#async-grid3-search","title":"<code>async-grid3 search</code>","text":"<p>Asynchronously searches for data from the GRID3 database.</p> <p>Args:     query (str): The search query.     table (bool): If True, renders results as a table; otherwise, prints the results directly.</p> <p>Usage:</p> <pre><code>$ async-grid3 search [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--query TEXT</code>: The search query.  [required]</li> <li><code>--table / --no-table</code>: If to render results as a table or not. Use --table to enable table (default) or --notable to disable table.  [default: table]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"cli/#docs","title":"<code>docs</code>","text":"<p>Launches the documentation website.</p> <p>Usage:</p> <pre><code>$ docs [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"cli/#grid3","title":"<code>grid3</code>","text":"<p>Usage:</p> <pre><code>$ grid3 [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <ul> <li><code>--help</code>: Show this message and exit.</li> </ul> <p>Commands:</p> <ul> <li><code>filter</code>: Filters data from the GRID3 database.</li> <li><code>info</code>: Retrieves information about a specific...</li> <li><code>list-data</code>: Lists the available datasets for Nigeria...</li> <li><code>search</code>: Searches for data from the GRID3 database.</li> </ul>"},{"location":"cli/#grid3-filter","title":"<code>grid3 filter</code>","text":"<p>Filters data from the GRID3 database.</p> <p>Args:     data_name (str): The name of the data to filter.     state (str, optional): The name of the state to filter for.     bbox (str, optional): The bounding box to filter with.     aoi_geometry (str, optional): The area of interest as a GeoJSON geometry string.     table (bool): If True, renders results as a table; otherwise, prints the results directly.</p> <p>Usage:</p> <pre><code>$ grid3 filter [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--data-name TEXT</code>: The name of the data to filter. e.g --data-name Nigeria_Health...  [required]</li> <li><code>--state TEXT</code>: The name of the state to filter for. Any from ['ABIA', 'ADAMAWA', 'AKWA_IBOM', 'ANAMBRA', 'BAUCHI', 'BAYELSA', 'BENUE', 'BORNO', 'CROSS_RIVER', 'DELTA', 'EBONYI', 'EDO', 'EKITI', 'ENUGU', 'GOMBE', 'IMO', 'JIGAWA', 'KADUNA', 'KANO', 'KATSINA', 'KEBBI', 'KOGI', 'KWARA', 'LAGOS', 'NASARAWA', 'NIGER', 'OGUN', 'ONDO', 'OSUN', 'OYO', 'PLATEAU', 'RIVERS', 'SOKOTO', 'TARABA', 'YOBE', 'ZAMFARA', 'FCT'] e.g --data-name abuja.</li> <li><code>--bbox TEXT</code>: The bounding box to filter with i.e 'min_x, min_y, max_x, max_y'. e.g --bbox '20.0, 12.3, 21.4, 34.5'.</li> <li><code>--aoi-geometry TEXT</code>: The aoi as a GeoJSON geometry string e.g --aoi-geometry '{'type': 'Point', 'coordinates': [30, 10]}'</li> <li><code>--table / --no-table</code>: If to render results as a table or not. Use --table to enable table (default) or --notable to disable table.  [default: table]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"cli/#grid3-info","title":"<code>grid3 info</code>","text":"<p>Retrieves information about a specific dataset from the GRID3 database.</p> <p>Args:     data_name (str): The name of the data to get information on.</p> <p>Usage:</p> <pre><code>$ grid3 info [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--data-name TEXT</code>: The name of the data to get information on. e.g --data-name Nigeria_Health...  [required]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"cli/#grid3-list-data","title":"<code>grid3 list-data</code>","text":"<p>Lists the available datasets for Nigeria from the GRID3 database.</p> <p>Args:     table (bool): If True, renders results as a table; otherwise, prints the results directly.</p> <p>Usage:</p> <pre><code>$ grid3 list-data [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--table / --no-table</code>: If to render results as a table or not. Use --table to enable table (default) or --notable to disable table.  [default: table]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"cli/#grid3-search","title":"<code>grid3 search</code>","text":"<p>Searches for data from the GRID3 database.</p> <p>Args:     query (str): The search query.     table (bool): If True, renders results as a table; otherwise, prints the results directly.</p> <p>Usage:</p> <pre><code>$ grid3 search [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--query TEXT</code>: The search query.  [required]</li> <li><code>--table / --no-table</code>: If to render results as a table or not. Use --table to enable table (default) or --notable to disable table.  [default: table]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"examples/geodata/","title":"Geodata Utils","text":"<p>The <code>Geodata Utils</code> module provides various utility functions for working with geospatial data. These utilities are designed to simplify common tasks such as converting between coordinate formats, validating geometries, and handling spatial references.</p> <p>Get all Nigeria States</p> <pre><code>from nigeria_geodata.utils import GeodataUtils\nnigeria_states = GeodataUtils.get_states()\nprint(nigeria_states)\n# returns all the states in Nigeria as a GeoJSON FeatureCollection.\n</code></pre> <p>Get the boundary of a Nigeria State</p> <pre><code>from nigeria_geodata.utils import GeodataUtils, NigeriaState\n\nlagos_state = GeodataUtils.get_state_geometry(NigeriaState.LAGOS)\nprint(lagos_state)\n# returns Lagos state boudary as a GeoJSON geometry.\n</code></pre>"},{"location":"examples/usage/","title":"Usage","text":""},{"location":"examples/usage/#list-all-available-datasets","title":"List all available datasets","text":"<p>By default, if <code>nigeria_geodata</code> finds pandas/geopandas already in your Python environment, it'll use it to render the results as a dataframe/geodataframe. However, you can disable this.</p> <p>Note: If you require your results as a dataframe/geodataframe, and you don't have it installed in your environment already, you can install the <code>standard</code> version which will install them for you, otherwise it'll throw a <code>PackageNotFoundError</code>. However, you can disable dataframe/geodataframe. More information is provided below.</p> pip install nigeria-geodata['standard']"},{"location":"examples/usage/#with-dataframe-default","title":"With dataframe (default)","text":"<pre><code>from nigeria_geodata import Grid3\ngrid3 = Grid3()\ngrid3.list_data()\n# returns all the available datasets as a dataframe.\n</code></pre>"},{"location":"examples/usage/#without-dataframe","title":"Without dataframe","text":"<pre><code>from nigeria_geodata import Grid3\ngrid3 = Grid3()\ngrid3.list_data(dataframe=False)\n# returns all the available datasets as an array.\n</code></pre>"},{"location":"examples/usage/#search-for-a-dataset","title":"Search for a dataset","text":"<pre><code>from nigeria_geodata import Grid3\ngrid3 = Grid3()\ngrid3.search(query='Health')\n# This will search through the GRDI3 database and return matching datasets.\n</code></pre> <p>If you're using the CLI, you'll see something like below. However, if you're using a Jupyter Notebook, you'll see a dataframe. Regardless of the environment, the results are the same.</p> <p></p>"},{"location":"examples/usage/#get-more-information-about-a-dataset","title":"Get more information about a dataset","text":"<p>After searching for a data of interest, or after viewing all the available datasets using <code>list_data()</code> method, you can then copy the name of the dataset of interest to clipboard. Or you can access it programmatically.</p>"},{"location":"examples/usage/#clipboard","title":"Clipboard","text":"<p>If you copied it to clipboard, just simply paste it here.</p> <pre><code>from nigeria_geodata import Grid3\ngrid3 = Grid3()\ninfo = grid3.info(data_name=\"NGA_HealthFacilities_v1_72\") # replace with the name of the dataset of interest\nprint(info)\n</code></pre>"},{"location":"examples/usage/#programmatic-access","title":"Programmatic access","text":"<p>If you got the response above as a dataframe or as a list (depending on whether you set <code>dataframe</code> to True or False). You can simply acess the index of the data you want and grab the <code>name</code>.</p> <pre><code>from nigeria_geodata import Grid3\ngrid3 = Grid3()\nsearch_results=grid3.search(query='Health')\ninfo = grid3.info(data_name=search_results[0]['Name']) # assuming the dataset of interest is in the first index.\nprint(info)\n</code></pre> <p></p>"},{"location":"examples/usage/#filter-a-dataset","title":"Filter a dataset","text":"<p>Similarly, you can filter a dataset using several parameters.</p>"},{"location":"examples/usage/#bounding-box","title":"Bounding box","text":"<p>If you have the bounding box of your area of interest, you can pass it to the filter function.</p> <p><pre><code>from nigeria_geodata import Grid3\ngrid3 = Grid3()\nsearch_results=grid3.search(query='Health')\nabuja_healthcare = grid3.filter(data_name=search_results[0]['Name'], bbox = [10.2, 3.4 , 5.6, 6.8]) # assuming Abuja bbox is this.\n# print(abuja_healthcare)\n</code></pre> This will return only the data about Abuja health care sites.</p>"},{"location":"examples/usage/#state-name","title":"State name","text":"<p>In addition to using the bounding box, which sometimes might extend beyong the actual boundary of the State/AOI, you can also use the State name. You can import the provided <code>enum</code>(recommended) from the <code>utils</code> module or you can type it manually (it is case inSEnsiTive).</p> <pre><code>from nigeria_geodata import Grid3\nfrom nigeria_geodata.utils import NigeriaState\ngrid3 = Grid3()\nsearch_results=grid3.search(query='Health')\nlagos_healthcare = grid3.filter(data_name=search_results[0]['Name'], state = NigeriaState.LAGOS)\n# print(lagos_healthcare)\n</code></pre>"},{"location":"examples/usage/#aoi-geometry","title":"AOI geometry","text":"<p>In addition to using the bounding box, or the state name,  you can also use a GeoJSON geometry.</p> <p>Note: It must be a valid GeoJSON Geometry, and can be of any geometry type.</p> <pre><code>from nigeria_geodata import Grid3\naoi_geometry = {\n  \"type\": \"Polygon\",\n  \"coordinates\": [\n    [\n      [-77.0369, 38.9072],\n      [-77.0369, 38.9172],\n      [-77.0269, 38.9172],\n      [-77.0269, 38.9072],\n      [-77.0369, 38.9072]\n    ]\n  ]\n}\ngrid3 = Grid3()\nsearch_results=grid3.search(query='Health')\naoi_healthcare = grid3.filter(data_name=search_results[0]['Name'], aoi_geometry = aoi_geometry)\n# print(aoi_healthcare)\n</code></pre>"},{"location":"examples/usage/#interactive-mapview","title":"Interactive mapview","text":"<p>One of the interesting feature is an interactive map (powered by Lonboard), which you can use to quickly visualize your dataset. This has only be tested to work in Notebook environment such as Jupyter Notebook. To enable this, pass <code>preview=True</code> to the <code>filter()</code> method like below:</p> <pre><code>from nigeria_geodata import Grid3\naoi_geometry = {\n  \"type\": \"Polygon\",\n  \"coordinates\": [\n    [\n      [-77.0369, 38.9072],\n      [-77.0369, 38.9172],\n      [-77.0269, 38.9172],\n      [-77.0269, 38.9072],\n      [-77.0369, 38.9072]\n    ]\n  ]\n}\ngrid3 = Grid3()\nsearch_results=grid3.search(query='Health')\naoi_healthcare = grid3.filter(data_name=search_results[0]['Name'], aoi_geometry = aoi_geometry, preview=True)\n# print(aoi_healthcare)\n</code></pre>"},{"location":"examples/usage/#without-filters","title":"Without filters","text":"<p>without passing any filtering parameter, you will still get results, but it'll be for the whole country.</p> <pre><code>from nigeria_geodata import Grid3\ngrid3 = Grid3()\nsearch_results=grid3.search(query='Health')\naoi_healthcare = grid3.filter(data_name=search_results[0]['Name'])\n# print(aoi_healthcare)\n</code></pre>"},{"location":"examples/usage/#async","title":"Async","text":"<p>The async module has a similar functionality to the sync method described above, however it is faster and uses a different class like below:</p> <pre><code>from nigeria_geodata import AsyncGrid3\ngrid3 = AsyncGrid3()\nawait grid3.list_data()\n# returns all the available datasets as a dataframe.\n</code></pre> <p>See benchmark for speed tests of both sync/async.</p>"}]}