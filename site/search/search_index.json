{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Nigeria Geodata","text":"<p>TODO - LOGO</p> <p>  A Python library for fast and efficient access to geospatial data for Nigeria. </p> <p> </p>"},{"location":"#todo-replace-with-actual-url-same-with-mkdocs","title":"todo - replace with actual url, same with mkdocs","text":"<p>Documentation: https://jeafreezy.github.io/nigeria_geodata/latest/</p> <p>Source Code: https://github.com/jeafreezy/nigeria_geodata</p> <p>Nigeria Geodata is a fast and efficient Python client for accessing geospatial data for Nigeria.</p> <p>The key features are:</p> <ul> <li>High Performance: Offers exceptional speed with both synchronous and asynchronous support to cater to different use cases and performance needs</li> <li>Map Visualization: Provides smooth map visualization using the fast lonboard library.</li> <li>Lightweight: Minimal dependencies\u2014just one required (httpx), with optional extras available for additional features.</li> <li>User-Friendly: Easy to use and learn; set up quickly with just a few lines of code.</li> <li>CLI Support: Intuitive command-line interface built with Typer.</li> <li>Real-Time Data: Fetches up-to-date data directly from the GRID3 database (more to come!), ensuring you always work with the latest information.</li> <li>Advanced Filtering: Allows for precise filtering based on state names (e.g FCT, Lagos), bounding boxes (bbox), and areas of interest (AOI).</li> </ul>"},{"location":"#dependency","title":"Dependency","text":"<p>nigeria_geodata depends on only one core package:</p> <ul> <li>Httpx - for the api requests.</li> </ul>"},{"location":"#additional-optional-dependencies","title":"Additional Optional Dependencies","text":"<p>There are some additional dependencies you might want to install.</p> <ul> <li>Typer - for cli support.</li> <li>Lonboard - for map visualization.</li> <li>Geopandas - to return the data as a geodataframe.</li> <li>Pandas - to return the data as a dataframe.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Create and activate a virtual environment and then install nigeria_geodata:</p> <p>To install the lightweight version using pip:</p> <pre><code>pip install nigeria-geodata\n</code></pre> <p>This version will return all the data as Python objects, mostly as a list, and list of dicts.</p> <p>To install it with <code>typer</code>, <code>lonboard</code> and <code>geopandas</code>:</p> <pre><code>pip install nigeria-geodata['standard']\n</code></pre> <p>This version will allow you to get the data as a dataframe, geodataframe, or an interactive mapview.</p> <pre><code>pip install nigeria-geodata['cli']\n</code></pre> <p>This version provides CLI support for the package. It is also lightweight -- It will return the data as pure Python objects.</p>"},{"location":"#get-started","title":"Get Started","text":"<p>For the simplest usecase, search for all the available health care data in Nigeria.</p> <pre><code># Sync\nfrom nigeria_geodata import Grid3, AsyncGrid3\nsearch_results = Grid3().search(\"health\")\nsearch_results\n# this will return a dataframe with all the available health care datasets.\n\n# Async\nsearch_results = await AsyncGrid3().search(\"health\")\nsearch_results\n# this will return a dataframe with all the available health care datasets.\n</code></pre> <p>Under the hood, this makes an api request to the GRID3 database to get the datasets. Refer to the documentation and examples for more use cases.</p>"},{"location":"#acknowledgment","title":"Acknowledgment","text":"<p>In addition to the great libraries we're resting upon, we would also like to thank GRID3 for providing real-time and comprehensive geospatial data that powers this library.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license. See LICENSE.MD.</p>"},{"location":"benchmark/","title":"Async","text":"<p>Benchmarks the time taken for asynchronous data filtering using the AsyncGrid3 class.</p> <p>This function initializes an AsyncGrid3 instance, performs an asynchronous filter operation on a specific dataset (\"NGA_HealthFacilities_v1_72\") and state (\"abuja\"), and prints the time taken for this operation.</p> Example <p>await benchmark_async()</p> Note <p>The performance results will vary based on the dataset size and system specifications.</p> Source code in <code>nigeria_geodata/benchmark.py</code> <pre><code>async def benchmark_async():\n    \"\"\"\n    Benchmarks the time taken for asynchronous data filtering using the AsyncGrid3 class.\n\n    This function initializes an AsyncGrid3 instance, performs an asynchronous filter operation\n    on a specific dataset (\"NGA_HealthFacilities_v1_72\") and state (\"abuja\"), and\n    prints the time taken for this operation.\n\n    Example:\n        await benchmark_async()\n\n    Note:\n        The performance results will vary based on the dataset size and system specifications.\n    \"\"\"\n    grid3 = AsyncGrid3()\n    start_time = time.time()\n    await grid3.filter(\"NGA_HealthFacilities_v1_72\", \"abuja\")\n    elapsed_time = time.time() - start_time\n    print(f\"Asynchronous call took {elapsed_time:.2f} seconds\")\n</code></pre>"},{"location":"benchmark/#sync","title":"Sync","text":"<p>Benchmarks the time taken for synchronous data filtering using the Grid3 class.</p> <p>This function initializes a Grid3 instance, performs a synchronous filter operation on a specific dataset (\"NGA_HealthFacilities_v1_72\") and state (\"abuja\"), and prints the time taken for this operation.</p> Example <p>benchmark_sync()</p> Note <p>The performance results will vary based on the dataset size and system specifications.</p> Source code in <code>nigeria_geodata/benchmark.py</code> <pre><code>def benchmark_sync():\n    \"\"\"\n    Benchmarks the time taken for synchronous data filtering using the Grid3 class.\n\n    This function initializes a Grid3 instance, performs a synchronous filter operation\n    on a specific dataset (\"NGA_HealthFacilities_v1_72\") and state (\"abuja\"), and\n    prints the time taken for this operation.\n\n    Example:\n        benchmark_sync()\n\n    Note:\n        The performance results will vary based on the dataset size and system specifications.\n    \"\"\"\n    grid3 = Grid3()\n    start_time = time.time()\n    grid3.filter(\n        \"NGA_HealthFacilities_v1_72\",\n        \"abuja\",\n    )\n    elapsed_time = time.time() - start_time\n    print(f\"Synchronous call took {elapsed_time:.2f} seconds\")\n</code></pre>"},{"location":"benchmark/#results","title":"Results","text":"<ul> <li>sync took 4.58 seconds.</li> <li>async took 0.98 seconds.</li> <li>machine - MBP 16inch. M3, 36 GB RAM.</li> </ul>"},{"location":"api/datasources/grid3/async/","title":"Async","text":"<p>               Bases: <code>AsyncBaseDataSource</code></p> Source code in <code>nigeria_geodata/datasources/grid3.py</code> <pre><code>class AsyncGrid3(AsyncBaseDataSource):\n    def __init__(self):\n        self.sync_grid3 = Grid3()\n\n    async def _run_sync(self, func, *args, **kwargs):\n        loop = asyncio.get_running_loop()\n        return await loop.run_in_executor(None, func, *args, **kwargs)\n\n    async def list_data(\n        self, dataframe: bool = True\n    ) -&gt; Union[List[EsriFeatureServiceBasicInfo], Optional[\"pd.DataFrame\"]]:\n        return await self._run_sync(self.sync_grid3.list_data, dataframe)\n\n    async def search(\n        self, query: str, dataframe: bool = True\n    ) -&gt; Union[List[EsriFeatureServiceBasicInfo], List, Optional[\"pd.DataFrame\"]]:\n        return await self._run_sync(self.sync_grid3.search, query, dataframe)\n\n    async def filter(\n        self,\n        data_name: str,\n        state: Optional[str] = None,\n        bbox: Optional[List[float]] = None,\n        aoi_geometry: Geometry = None,\n        preview: bool = False,\n        geodataframe: bool = False,\n    ) -&gt; Union[\n        Optional[\"gpd.GeoDataFrame\"],\n        Optional[\"Map\"],\n        List[Dict[str, Any]],\n    ]:\n        return await self._run_sync(\n            self.sync_grid3.filter,\n            data_name,\n            state,\n            bbox,\n            aoi_geometry,\n            preview,\n            geodataframe,\n        )\n\n    async def info(\n        self, data_name: str, dataframe: bool = True\n    ) -&gt; Union[EsriFeatureLayerInfo, Optional[\"pd.DataFrame\"], Dict[str, Any]]:\n        return await self._run_sync(self.sync_grid3.info, data_name, dataframe)\n\n    def __repr__(self) -&gt; str:\n        return \"&lt;AsyncGrid3DataSource&gt;\"\n</code></pre>"},{"location":"api/datasources/grid3/sync/","title":"Sync","text":"<p>               Bases: <code>SyncBaseDataSource</code></p> Source code in <code>nigeria_geodata/datasources/grid3.py</code> <pre><code>class Grid3(SyncBaseDataSource):\n    service_url: str = Config.get_service_url(DataSource.GRID3)\n    service_info_url: str = Config.get_service_info_url(DataSource.GRID3)\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        # fetch at initialization for optimal performance\n        self.feature_services = self._get_feature_services()\n\n    def _get_feature_services(self) -&gt; List[EsriFeatureServiceBasicInfo]:\n        \"\"\"\n        Retrieve the available feature services containing Nigeria data from the ArcGIS Server root directory.\n\n        This method fetches the feature services from the Grid3 server and filters out\n        those relevant to Nigeria, identified by either \"NGA\" or \"NIGERIA\" in the service name.\n\n        Returns:\n            List[EsriFeatureServiceBasicInfo]: A list of feature services with basic metadata\n                                               (name, URL, and type) relevant to Nigeria.\n        \"\"\"\n\n        api_response = make_request(self.service_url)\n\n        # based on review of the datasets, Nigeria is either represented as Nigeria or NGA\n        # For now it works, but this has a potential for improvement.\n        feature_services = list(\n            map(\n                lambda feature_service: EsriFeatureServiceBasicInfo(\n                    feature_service[\"name\"],\n                    feature_service[\"url\"],\n                    feature_service[\"type\"],\n                ),\n                filter(\n                    lambda response_obj: \"NGA\" in str(response_obj[\"name\"]).upper()\n                    or \"NIGERIA\" in str(response_obj[\"name\"]).upper(),\n                    api_response.get(\"services\", []),\n                ),\n            ),\n        )\n        self.feature_services = feature_services\n        return feature_services\n\n    def __find_and_validate_name(self, data_name) -&gt; List[EsriFeatureServiceBasicInfo]:\n        \"\"\"\n        Validate the existence of a dataset by name.\n\n        This method checks if a dataset with the given name exists within the available\n        Grid3 feature services. If it doesn't exist, it raises a ValueError.\n\n        Args:\n            data_name (str): The name of the dataset to search for.\n\n        Returns:\n            List[EsriFeatureServiceBasicInfo]: A list of matching feature services (if found).\n\n        Raises:\n            ValueError: If the provided data name does not exist in the Grid3 database.\n        \"\"\"\n        data_exist = [\n            service\n            for service in self.feature_services\n            if service.name.lower() == data_name.lower()\n        ]\n        if len(data_exist) == 0:\n            msg = f\"The provided data name '{data_name}' does not exist in the Grid3 database.\"\n            logger.error(msg)\n            raise ValueError(msg)\n        return data_exist\n\n    def __get_max_features(self, service_url: str) -&gt; int:\n        \"\"\"\n        Retrieve the maximum number of features available in a given feature service.\n\n        This method makes a request to the Grid3 server to count the number of features\n        in the dataset by performing a statistics query.\n\n        Args:\n            service_url (str): The URL of the feature service to query.\n\n        Returns:\n            int: The total number of features available in the dataset.\n        \"\"\"\n        params = {\n            \"where\": \"FID &gt; 0\",\n            \"groupByFieldsForStatistics\": \"\",\n            \"orderByFields\": \"\",\n            \"returnDistinctValues\": \"true\",\n            \"outStatistics\": [\n                [\n                    {\n                        \"statisticType\": \"count\",\n                        \"onStatisticField\": \"FID\",\n                        \"outStatisticFieldName\": \"COUNT\",\n                    }\n                ]\n            ],\n            \"f\": \"json\",\n        }\n        res = make_request(service_url, params=params)\n        return res[\"features\"][0][\"attributes\"][\"COUNT\"]\n\n    def list_data(\n        self, dataframe: bool = True\n    ) -&gt; Union[List[EsriFeatureServiceBasicInfo], Optional[\"pd.DataFrame\"]]:\n        \"\"\"\n        List available datasets from the Grid3 data source.\n\n        This method retrieves a list of all datasets available in the Grid3 data source.\n        It can return the information either as a list of `EsriFeatureServiceBasicInfo`\n        objects or as a pandas DataFrame, depending on the `dataframe` parameter.\n\n        Args:\n            dataframe (bool): If True, returns the information as a pandas DataFrame.\n                              If False, returns a list of `EsriFeatureServiceBasicInfo` objects.\n\n        Returns:\n            Union[List[EsriFeatureServiceBasicInfo], Optional[\"pd.DataFrame\"]]: A list of\n            `EsriFeatureServiceBasicInfo` objects or a pandas DataFrame containing dataset information.\n        \"\"\"\n        total_services = len(self.feature_services)\n        # Note: a feature server can have many layers, but inspecting the Grid3 service\n        # all the feature server have a single layer for a single dataset\n        # although the id of the layers are different.\n        logger.info(\n            f\"There is a total {total_services + 1} Nigeria geodata in the Grid3 database.\"\n        )\n        if dataframe:\n            pd = CheckDependencies.pandas()\n            data = {\n                \"id\": list(range(total_services)),\n                \"name\": [\n                    feature_service.name for feature_service in self.feature_services\n                ],\n            }\n            return pd.DataFrame(data)\n        # return a dict for those that don't want a dataframe or don't have pandas installed.\n        return [x.__dict__ for x in self.feature_services]\n\n    def search(\n        self, query: str, dataframe: bool = True\n    ) -&gt; Union[List[EsriFeatureServiceBasicInfo], List, Optional[\"pd.DataFrame\"]]:\n        \"\"\"\n        Search the Grid3 data source for datasets matching a query string.\n\n        This method searches for datasets whose names contain the specified query string.\n        It can return the search results as a list of `EsriFeatureServiceBasicInfo`\n        objects or as a pandas DataFrame, depending on the `dataframe` parameter.\n\n        Args:\n            query (str): The query string to search for in the dataset names.\n            dataframe (bool): If True, returns the search results as a pandas DataFrame.\n                              If False, returns a list of `EsriFeatureServiceBasicInfo` objects.\n\n        Returns:\n            Union[List[EsriFeatureServiceBasicInfo], List, Optional[\"pd.DataFrame\"]]: A list of\n            `EsriFeatureServiceBasicInfo` objects matching the query or a pandas DataFrame of results.\n        \"\"\"\n        search_results = list(\n            filter(\n                lambda feature_server: query.upper()\n                in str(feature_server.name).upper(),\n                self.feature_services,\n            ),\n        )\n\n        total_results = len(search_results)\n        logger.info(f\"Search query for '{query}' returned {total_results} results.\")\n\n        if len(search_results) &gt; 0:\n            if dataframe:\n                pd = CheckDependencies.pandas()\n                # they don't need to see the url when rendering the dataframe.\n                data = {\n                    \"id\": list(range(total_results)),\n                    \"name\": [\n                        feature_service.name for feature_service in search_results\n                    ],\n                }\n                return pd.DataFrame(data)\n\n            # return it as a list of dict\n            return [x.__dict__ for x in search_results]\n        print(\n            f\"Search query for '{query}' did not match any available datasets. Try another query or use `Grid3().list_data()` to see available datasets.\"\n        )\n        return []\n\n    def info(\n        self, data_name: str, dataframe: bool = True\n    ) -&gt; Union[EsriFeatureLayerInfo, Optional[\"pd.DataFrame\"], Dict[str, Any]]:\n        \"\"\"\n        Retrieve detailed information about a specific dataset from the Grid3 data source.\n\n        This method provides detailed information about a dataset, including metadata and\n        layer details, by connecting to the feature service. The information can be returned\n        as an `EsriFeatureLayerInfo` object or as a pandas DataFrame, depending on the\n        `dataframe` parameter.\n\n        Args:\n            data_name (str): The name of the dataset to retrieve information about.\n            dataframe (bool): If True, returns the information as a pandas DataFrame.\n                              If False, returns an `EsriFeatureLayerInfo` object.\n\n        Returns:\n            Union[EsriFeatureLayerInfo, Optional[\"pd.DataFrame\"], Dict[str, Any]]: Detailed\n            information about the dataset as an `EsriFeatureLayerInfo` object or a pandas DataFrame.\n        \"\"\"\n        search_result = self.__find_and_validate_name(data_name)\n\n        query_params = {\"f\": \"json\"}\n        # incase it returns multiple just use the first one.\n        feature_server = search_result[0]\n        response = make_request(f\"{feature_server.url}\", query_params)\n        # make a request to the actual layer to get the last edited date\n        layer_response = make_request(\n            f\"{feature_server.url}/{response['layers'][0]['id']}\", query_params\n        )\n        feature_service = EsriFeatureLayerInfo(\n            layerName=layer_response[\"name\"],\n            layerGeometryType=layer_response[\"geometryType\"],\n            layerObjectIdField=layer_response[\"objectIdField\"],\n            layerId=response[\"layers\"][0][\"id\"],\n            serviceDescription=response[\"serviceDescription\"],\n            serviceItemId=response[\"serviceItemId\"],\n            maxRecordCount=response[\"maxRecordCount\"],\n            supportedQueryFormats=response[\"supportedQueryFormats\"],\n            supportedExportFormats=response[\"supportedExportFormats\"],\n            capabilities=response[\"capabilities\"],\n            description=response[\"description\"],\n            copyrightText=response[\"copyrightText\"],\n            spatialReference=response[\"spatialReference\"],\n            fullExtent=response[\"fullExtent\"],\n            layers=response[\"layers\"],\n            tables=response[\"tables\"],\n            featureServerURL=feature_server.url,\n            layerLastUpdated=timestamp_to_datetime(\n                layer_response[\"editingInfo\"][\"dataLastEditDate\"]\n            ),\n            totalFeatures=self.__get_max_features(\n                f\"{feature_server.url}/{response['layers'][0]['id']}/query\"\n            ),\n        )\n        if dataframe:\n            pd = CheckDependencies.pandas()\n            data = feature_service.__dict__.copy()\n            transformed_data = {\"Key\": list(data.keys()), \"Value\": list(data.values())}\n            return pd.DataFrame(transformed_data)\n        return feature_service.__dict__\n\n    def filter(\n        self,\n        data_name: str,\n        state: Optional[str] = None,\n        bbox: Optional[List[float]] = None,\n        aoi_geometry: Geometry = None,\n        preview: bool = False,\n        geodataframe: bool = True,\n    ) -&gt; Union[\n        Optional[\"gpd.GeoDataFrame\"],\n        Optional[\"Map\"],\n        List[Dict[str, Any]],\n    ]:\n        \"\"\"\n        Filter datasets based on specified criteria and retrieve the results.\n\n        This method filters the dataset based on the provided state, bounding box (bbox),\n        or area of interest (aoi_geometry). It retrieves the filtered data and can return\n        it as a GeoDataFrame, a preview map, or as a list of feature dictionaries.\n\n        Args:\n            data_name (str): The name of the dataset to filter.\n            state (Optional[str]): The name of the Nigerian state to filter by (if applicable).\n            bbox (Optional[List[float]]): The bounding box to filter by, defined as [xmin, ymin, xmax, ymax].\n            aoi_geometry (Geometry): The area of interest geometry to filter by.\n            preview (bool): If True, returns a preview map of the filtered results.\n                            If False, returns the filtered data without a preview.\n            geodataframe (bool): If True, returns the filtered data as a GeoDataFrame.\n                                 If False, returns a list of feature dictionaries.\n\n        Returns:\n            Union[Optional[\"gpd.GeoDataFrame\"], Optional[\"Map\"], List[Dict[str, Any]]]:\n            The filtered dataset as a GeoDataFrame, a preview map, or a list of feature dictionaries.\n        \"\"\"\n        feature_service = self.info(data_name, False)\n\n        # only one parameter can be provided, so this check is to ensure that.\n        params = sum([state is not None, bbox is not None, aoi_geometry is not None])\n\n        if params &gt; 1:\n            raise ValueError(\n                \"Only one parameter (state, bbox, or aoi_geometry) can be provided.\"\n            )\n\n        # defaults\n        esri_geometry = None\n        geometryType = \"esriGeometryEnvelope\"  # default to the esriGeometryEnvelope which is like the bbox.\n\n        # State validation\n        if state:\n            valid_states = [x.value.lower() for x in NigeriaState]\n            if state.lower() not in valid_states:\n                raise ValueError(\n                    f\"The provided state '{state}' is not a valid Nigeria State. Available states are: {', '.join(valid_states)}\"\n                )\n            # update esri geometry\n            geometryType = \"esriGeometryPolygon\"\n            esri_geometry = GeodataUtils.geojson_to_esri_json(\n                GeodataUtils.get_state_geometry(state)\n            )\n\n        # bbox validation\n        if bbox:\n            if len(bbox) != 4 or not all(\n                isinstance(coord, (int, float)) for coord in bbox\n            ):\n                raise ValueError(\n                    \"The provided bbox is invalid. It should be a list of four numeric values.\"\n                )\n            # update esribbox\n            esri_geometry = bbox\n\n        if aoi_geometry:\n            if not GeodataUtils.validate_geojson_geometry(aoi_geometry):\n                raise ValueError(\"The provided aoi_geometry is invalid.\")\n\n            geometryType = GeodataUtils.geojson_to_esri_type(aoi_geometry[\"type\"])\n            esri_geometry = GeodataUtils.geojson_to_esri_json(aoi_geometry)\n\n        params = {\n            \"where\": f\"{feature_service['layerObjectIdField']} &gt; 0\",  # this is required\n            \"geometryType\": geometryType,\n            \"f\": \"geojson\",\n            \"outFields\": \"*\",  # to return all the attributes of the data\n            \"spatialRel\": \"esriSpatialRelIntersects\",\n        }\n\n        # update the params if the user filters by state or bbox\n        if esri_geometry:\n            if bbox:\n                params.update({\"geometry\": \",\".join(map(str, esri_geometry))})\n            if aoi_geometry or state:\n                params.update({\"geometry\": esri_geometry})\n\n        max_features = feature_service[\"totalFeatures\"]\n        if max_features == 0:\n            return []\n        result_list = []\n        resultOffset = 0\n        max_request = ceil(max_features / feature_service[\"maxRecordCount\"])\n        for _ in range(max_request):\n            params[\"resultOffset\"] = resultOffset\n            response = make_request(\n                f\"{feature_service['featureServerURL']}/{feature_service['layerId']}/query\",\n                params=params,\n                method=RequestMethod.POST,\n            )\n            features = response[\"features\"]\n            result_list.extend(features)\n            resultOffset += feature_service[\"maxRecordCount\"]\n            # check the length of the response, if it's less than the maxRecordCount then we can break\n            # e.g when filtering, the result might not be up to 2000 i.e the maxRecordCount, so instead of making multiple requests\n            # based on the total dataset i.e max_features, we can break it here.\n            # an alternative is to hit the statistics endpoint with the filtering to get the maximum features for the query\n            # but that's going to be another query. So this approach works fine for now.\n            # Will require more testing.\n            if len(features) &lt; feature_service[\"maxRecordCount\"]:\n                break\n\n        if geodataframe or preview:\n            if len(result_list) &gt; 0:\n                gpd = CheckDependencies.geopandas()\n                gdf = gpd.GeoDataFrame.from_features(\n                    result_list,\n                    crs=f\"EPSG:{feature_service['spatialReference']['wkid']}\",\n                )\n                if preview:\n                    viz = CheckDependencies.lonboard()\n                    return viz(gdf)\n                # otherwise return the gdf\n                return gdf\n        return result_list\n\n    def __repr__(self) -&gt; str:\n        return \"&lt;Grid3DataSource}&gt;\"\n</code></pre>"},{"location":"api/datasources/grid3/sync/#nigeria_geodata.datasources.grid3.Grid3.__find_and_validate_name","title":"<code>__find_and_validate_name(data_name)</code>","text":"<p>Validate the existence of a dataset by name.</p> <p>This method checks if a dataset with the given name exists within the available Grid3 feature services. If it doesn't exist, it raises a ValueError.</p> <p>Parameters:</p> Name Type Description Default <code>data_name</code> <code>str</code> <p>The name of the dataset to search for.</p> required <p>Returns:</p> Type Description <code>List[EsriFeatureServiceBasicInfo]</code> <p>List[EsriFeatureServiceBasicInfo]: A list of matching feature services (if found).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided data name does not exist in the Grid3 database.</p> Source code in <code>nigeria_geodata/datasources/grid3.py</code> <pre><code>def __find_and_validate_name(self, data_name) -&gt; List[EsriFeatureServiceBasicInfo]:\n    \"\"\"\n    Validate the existence of a dataset by name.\n\n    This method checks if a dataset with the given name exists within the available\n    Grid3 feature services. If it doesn't exist, it raises a ValueError.\n\n    Args:\n        data_name (str): The name of the dataset to search for.\n\n    Returns:\n        List[EsriFeatureServiceBasicInfo]: A list of matching feature services (if found).\n\n    Raises:\n        ValueError: If the provided data name does not exist in the Grid3 database.\n    \"\"\"\n    data_exist = [\n        service\n        for service in self.feature_services\n        if service.name.lower() == data_name.lower()\n    ]\n    if len(data_exist) == 0:\n        msg = f\"The provided data name '{data_name}' does not exist in the Grid3 database.\"\n        logger.error(msg)\n        raise ValueError(msg)\n    return data_exist\n</code></pre>"},{"location":"api/datasources/grid3/sync/#nigeria_geodata.datasources.grid3.Grid3.__get_max_features","title":"<code>__get_max_features(service_url)</code>","text":"<p>Retrieve the maximum number of features available in a given feature service.</p> <p>This method makes a request to the Grid3 server to count the number of features in the dataset by performing a statistics query.</p> <p>Parameters:</p> Name Type Description Default <code>service_url</code> <code>str</code> <p>The URL of the feature service to query.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The total number of features available in the dataset.</p> Source code in <code>nigeria_geodata/datasources/grid3.py</code> <pre><code>def __get_max_features(self, service_url: str) -&gt; int:\n    \"\"\"\n    Retrieve the maximum number of features available in a given feature service.\n\n    This method makes a request to the Grid3 server to count the number of features\n    in the dataset by performing a statistics query.\n\n    Args:\n        service_url (str): The URL of the feature service to query.\n\n    Returns:\n        int: The total number of features available in the dataset.\n    \"\"\"\n    params = {\n        \"where\": \"FID &gt; 0\",\n        \"groupByFieldsForStatistics\": \"\",\n        \"orderByFields\": \"\",\n        \"returnDistinctValues\": \"true\",\n        \"outStatistics\": [\n            [\n                {\n                    \"statisticType\": \"count\",\n                    \"onStatisticField\": \"FID\",\n                    \"outStatisticFieldName\": \"COUNT\",\n                }\n            ]\n        ],\n        \"f\": \"json\",\n    }\n    res = make_request(service_url, params=params)\n    return res[\"features\"][0][\"attributes\"][\"COUNT\"]\n</code></pre>"},{"location":"api/datasources/grid3/sync/#nigeria_geodata.datasources.grid3.Grid3.filter","title":"<code>filter(data_name, state=None, bbox=None, aoi_geometry=None, preview=False, geodataframe=True)</code>","text":"<p>Filter datasets based on specified criteria and retrieve the results.</p> <p>This method filters the dataset based on the provided state, bounding box (bbox), or area of interest (aoi_geometry). It retrieves the filtered data and can return it as a GeoDataFrame, a preview map, or as a list of feature dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>data_name</code> <code>str</code> <p>The name of the dataset to filter.</p> required <code>state</code> <code>Optional[str]</code> <p>The name of the Nigerian state to filter by (if applicable).</p> <code>None</code> <code>bbox</code> <code>Optional[List[float]]</code> <p>The bounding box to filter by, defined as [xmin, ymin, xmax, ymax].</p> <code>None</code> <code>aoi_geometry</code> <code>Geometry</code> <p>The area of interest geometry to filter by.</p> <code>None</code> <code>preview</code> <code>bool</code> <p>If True, returns a preview map of the filtered results.             If False, returns the filtered data without a preview.</p> <code>False</code> <code>geodataframe</code> <code>bool</code> <p>If True, returns the filtered data as a GeoDataFrame.                  If False, returns a list of feature dictionaries.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[Optional[GeoDataFrame], Optional[Map], List[Dict[str, Any]]]</code> <p>Union[Optional[\"gpd.GeoDataFrame\"], Optional[\"Map\"], List[Dict[str, Any]]]:</p> <code>Union[Optional[GeoDataFrame], Optional[Map], List[Dict[str, Any]]]</code> <p>The filtered dataset as a GeoDataFrame, a preview map, or a list of feature dictionaries.</p> Source code in <code>nigeria_geodata/datasources/grid3.py</code> <pre><code>def filter(\n    self,\n    data_name: str,\n    state: Optional[str] = None,\n    bbox: Optional[List[float]] = None,\n    aoi_geometry: Geometry = None,\n    preview: bool = False,\n    geodataframe: bool = True,\n) -&gt; Union[\n    Optional[\"gpd.GeoDataFrame\"],\n    Optional[\"Map\"],\n    List[Dict[str, Any]],\n]:\n    \"\"\"\n    Filter datasets based on specified criteria and retrieve the results.\n\n    This method filters the dataset based on the provided state, bounding box (bbox),\n    or area of interest (aoi_geometry). It retrieves the filtered data and can return\n    it as a GeoDataFrame, a preview map, or as a list of feature dictionaries.\n\n    Args:\n        data_name (str): The name of the dataset to filter.\n        state (Optional[str]): The name of the Nigerian state to filter by (if applicable).\n        bbox (Optional[List[float]]): The bounding box to filter by, defined as [xmin, ymin, xmax, ymax].\n        aoi_geometry (Geometry): The area of interest geometry to filter by.\n        preview (bool): If True, returns a preview map of the filtered results.\n                        If False, returns the filtered data without a preview.\n        geodataframe (bool): If True, returns the filtered data as a GeoDataFrame.\n                             If False, returns a list of feature dictionaries.\n\n    Returns:\n        Union[Optional[\"gpd.GeoDataFrame\"], Optional[\"Map\"], List[Dict[str, Any]]]:\n        The filtered dataset as a GeoDataFrame, a preview map, or a list of feature dictionaries.\n    \"\"\"\n    feature_service = self.info(data_name, False)\n\n    # only one parameter can be provided, so this check is to ensure that.\n    params = sum([state is not None, bbox is not None, aoi_geometry is not None])\n\n    if params &gt; 1:\n        raise ValueError(\n            \"Only one parameter (state, bbox, or aoi_geometry) can be provided.\"\n        )\n\n    # defaults\n    esri_geometry = None\n    geometryType = \"esriGeometryEnvelope\"  # default to the esriGeometryEnvelope which is like the bbox.\n\n    # State validation\n    if state:\n        valid_states = [x.value.lower() for x in NigeriaState]\n        if state.lower() not in valid_states:\n            raise ValueError(\n                f\"The provided state '{state}' is not a valid Nigeria State. Available states are: {', '.join(valid_states)}\"\n            )\n        # update esri geometry\n        geometryType = \"esriGeometryPolygon\"\n        esri_geometry = GeodataUtils.geojson_to_esri_json(\n            GeodataUtils.get_state_geometry(state)\n        )\n\n    # bbox validation\n    if bbox:\n        if len(bbox) != 4 or not all(\n            isinstance(coord, (int, float)) for coord in bbox\n        ):\n            raise ValueError(\n                \"The provided bbox is invalid. It should be a list of four numeric values.\"\n            )\n        # update esribbox\n        esri_geometry = bbox\n\n    if aoi_geometry:\n        if not GeodataUtils.validate_geojson_geometry(aoi_geometry):\n            raise ValueError(\"The provided aoi_geometry is invalid.\")\n\n        geometryType = GeodataUtils.geojson_to_esri_type(aoi_geometry[\"type\"])\n        esri_geometry = GeodataUtils.geojson_to_esri_json(aoi_geometry)\n\n    params = {\n        \"where\": f\"{feature_service['layerObjectIdField']} &gt; 0\",  # this is required\n        \"geometryType\": geometryType,\n        \"f\": \"geojson\",\n        \"outFields\": \"*\",  # to return all the attributes of the data\n        \"spatialRel\": \"esriSpatialRelIntersects\",\n    }\n\n    # update the params if the user filters by state or bbox\n    if esri_geometry:\n        if bbox:\n            params.update({\"geometry\": \",\".join(map(str, esri_geometry))})\n        if aoi_geometry or state:\n            params.update({\"geometry\": esri_geometry})\n\n    max_features = feature_service[\"totalFeatures\"]\n    if max_features == 0:\n        return []\n    result_list = []\n    resultOffset = 0\n    max_request = ceil(max_features / feature_service[\"maxRecordCount\"])\n    for _ in range(max_request):\n        params[\"resultOffset\"] = resultOffset\n        response = make_request(\n            f\"{feature_service['featureServerURL']}/{feature_service['layerId']}/query\",\n            params=params,\n            method=RequestMethod.POST,\n        )\n        features = response[\"features\"]\n        result_list.extend(features)\n        resultOffset += feature_service[\"maxRecordCount\"]\n        # check the length of the response, if it's less than the maxRecordCount then we can break\n        # e.g when filtering, the result might not be up to 2000 i.e the maxRecordCount, so instead of making multiple requests\n        # based on the total dataset i.e max_features, we can break it here.\n        # an alternative is to hit the statistics endpoint with the filtering to get the maximum features for the query\n        # but that's going to be another query. So this approach works fine for now.\n        # Will require more testing.\n        if len(features) &lt; feature_service[\"maxRecordCount\"]:\n            break\n\n    if geodataframe or preview:\n        if len(result_list) &gt; 0:\n            gpd = CheckDependencies.geopandas()\n            gdf = gpd.GeoDataFrame.from_features(\n                result_list,\n                crs=f\"EPSG:{feature_service['spatialReference']['wkid']}\",\n            )\n            if preview:\n                viz = CheckDependencies.lonboard()\n                return viz(gdf)\n            # otherwise return the gdf\n            return gdf\n    return result_list\n</code></pre>"},{"location":"api/datasources/grid3/sync/#nigeria_geodata.datasources.grid3.Grid3.info","title":"<code>info(data_name, dataframe=True)</code>","text":"<p>Retrieve detailed information about a specific dataset from the Grid3 data source.</p> <p>This method provides detailed information about a dataset, including metadata and layer details, by connecting to the feature service. The information can be returned as an <code>EsriFeatureLayerInfo</code> object or as a pandas DataFrame, depending on the <code>dataframe</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>data_name</code> <code>str</code> <p>The name of the dataset to retrieve information about.</p> required <code>dataframe</code> <code>bool</code> <p>If True, returns the information as a pandas DataFrame.               If False, returns an <code>EsriFeatureLayerInfo</code> object.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[EsriFeatureLayerInfo, Optional[DataFrame], Dict[str, Any]]</code> <p>Union[EsriFeatureLayerInfo, Optional[\"pd.DataFrame\"], Dict[str, Any]]: Detailed</p> <code>Union[EsriFeatureLayerInfo, Optional[DataFrame], Dict[str, Any]]</code> <p>information about the dataset as an <code>EsriFeatureLayerInfo</code> object or a pandas DataFrame.</p> Source code in <code>nigeria_geodata/datasources/grid3.py</code> <pre><code>def info(\n    self, data_name: str, dataframe: bool = True\n) -&gt; Union[EsriFeatureLayerInfo, Optional[\"pd.DataFrame\"], Dict[str, Any]]:\n    \"\"\"\n    Retrieve detailed information about a specific dataset from the Grid3 data source.\n\n    This method provides detailed information about a dataset, including metadata and\n    layer details, by connecting to the feature service. The information can be returned\n    as an `EsriFeatureLayerInfo` object or as a pandas DataFrame, depending on the\n    `dataframe` parameter.\n\n    Args:\n        data_name (str): The name of the dataset to retrieve information about.\n        dataframe (bool): If True, returns the information as a pandas DataFrame.\n                          If False, returns an `EsriFeatureLayerInfo` object.\n\n    Returns:\n        Union[EsriFeatureLayerInfo, Optional[\"pd.DataFrame\"], Dict[str, Any]]: Detailed\n        information about the dataset as an `EsriFeatureLayerInfo` object or a pandas DataFrame.\n    \"\"\"\n    search_result = self.__find_and_validate_name(data_name)\n\n    query_params = {\"f\": \"json\"}\n    # incase it returns multiple just use the first one.\n    feature_server = search_result[0]\n    response = make_request(f\"{feature_server.url}\", query_params)\n    # make a request to the actual layer to get the last edited date\n    layer_response = make_request(\n        f\"{feature_server.url}/{response['layers'][0]['id']}\", query_params\n    )\n    feature_service = EsriFeatureLayerInfo(\n        layerName=layer_response[\"name\"],\n        layerGeometryType=layer_response[\"geometryType\"],\n        layerObjectIdField=layer_response[\"objectIdField\"],\n        layerId=response[\"layers\"][0][\"id\"],\n        serviceDescription=response[\"serviceDescription\"],\n        serviceItemId=response[\"serviceItemId\"],\n        maxRecordCount=response[\"maxRecordCount\"],\n        supportedQueryFormats=response[\"supportedQueryFormats\"],\n        supportedExportFormats=response[\"supportedExportFormats\"],\n        capabilities=response[\"capabilities\"],\n        description=response[\"description\"],\n        copyrightText=response[\"copyrightText\"],\n        spatialReference=response[\"spatialReference\"],\n        fullExtent=response[\"fullExtent\"],\n        layers=response[\"layers\"],\n        tables=response[\"tables\"],\n        featureServerURL=feature_server.url,\n        layerLastUpdated=timestamp_to_datetime(\n            layer_response[\"editingInfo\"][\"dataLastEditDate\"]\n        ),\n        totalFeatures=self.__get_max_features(\n            f\"{feature_server.url}/{response['layers'][0]['id']}/query\"\n        ),\n    )\n    if dataframe:\n        pd = CheckDependencies.pandas()\n        data = feature_service.__dict__.copy()\n        transformed_data = {\"Key\": list(data.keys()), \"Value\": list(data.values())}\n        return pd.DataFrame(transformed_data)\n    return feature_service.__dict__\n</code></pre>"},{"location":"api/datasources/grid3/sync/#nigeria_geodata.datasources.grid3.Grid3.list_data","title":"<code>list_data(dataframe=True)</code>","text":"<p>List available datasets from the Grid3 data source.</p> <p>This method retrieves a list of all datasets available in the Grid3 data source. It can return the information either as a list of <code>EsriFeatureServiceBasicInfo</code> objects or as a pandas DataFrame, depending on the <code>dataframe</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>dataframe</code> <code>bool</code> <p>If True, returns the information as a pandas DataFrame.               If False, returns a list of <code>EsriFeatureServiceBasicInfo</code> objects.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[List[EsriFeatureServiceBasicInfo], Optional[DataFrame]]</code> <p>Union[List[EsriFeatureServiceBasicInfo], Optional[\"pd.DataFrame\"]]: A list of</p> <code>Union[List[EsriFeatureServiceBasicInfo], Optional[DataFrame]]</code> <p><code>EsriFeatureServiceBasicInfo</code> objects or a pandas DataFrame containing dataset information.</p> Source code in <code>nigeria_geodata/datasources/grid3.py</code> <pre><code>def list_data(\n    self, dataframe: bool = True\n) -&gt; Union[List[EsriFeatureServiceBasicInfo], Optional[\"pd.DataFrame\"]]:\n    \"\"\"\n    List available datasets from the Grid3 data source.\n\n    This method retrieves a list of all datasets available in the Grid3 data source.\n    It can return the information either as a list of `EsriFeatureServiceBasicInfo`\n    objects or as a pandas DataFrame, depending on the `dataframe` parameter.\n\n    Args:\n        dataframe (bool): If True, returns the information as a pandas DataFrame.\n                          If False, returns a list of `EsriFeatureServiceBasicInfo` objects.\n\n    Returns:\n        Union[List[EsriFeatureServiceBasicInfo], Optional[\"pd.DataFrame\"]]: A list of\n        `EsriFeatureServiceBasicInfo` objects or a pandas DataFrame containing dataset information.\n    \"\"\"\n    total_services = len(self.feature_services)\n    # Note: a feature server can have many layers, but inspecting the Grid3 service\n    # all the feature server have a single layer for a single dataset\n    # although the id of the layers are different.\n    logger.info(\n        f\"There is a total {total_services + 1} Nigeria geodata in the Grid3 database.\"\n    )\n    if dataframe:\n        pd = CheckDependencies.pandas()\n        data = {\n            \"id\": list(range(total_services)),\n            \"name\": [\n                feature_service.name for feature_service in self.feature_services\n            ],\n        }\n        return pd.DataFrame(data)\n    # return a dict for those that don't want a dataframe or don't have pandas installed.\n    return [x.__dict__ for x in self.feature_services]\n</code></pre>"},{"location":"api/datasources/grid3/sync/#nigeria_geodata.datasources.grid3.Grid3.search","title":"<code>search(query, dataframe=True)</code>","text":"<p>Search the Grid3 data source for datasets matching a query string.</p> <p>This method searches for datasets whose names contain the specified query string. It can return the search results as a list of <code>EsriFeatureServiceBasicInfo</code> objects or as a pandas DataFrame, depending on the <code>dataframe</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query string to search for in the dataset names.</p> required <code>dataframe</code> <code>bool</code> <p>If True, returns the search results as a pandas DataFrame.               If False, returns a list of <code>EsriFeatureServiceBasicInfo</code> objects.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[List[EsriFeatureServiceBasicInfo], List, Optional[DataFrame]]</code> <p>Union[List[EsriFeatureServiceBasicInfo], List, Optional[\"pd.DataFrame\"]]: A list of</p> <code>Union[List[EsriFeatureServiceBasicInfo], List, Optional[DataFrame]]</code> <p><code>EsriFeatureServiceBasicInfo</code> objects matching the query or a pandas DataFrame of results.</p> Source code in <code>nigeria_geodata/datasources/grid3.py</code> <pre><code>def search(\n    self, query: str, dataframe: bool = True\n) -&gt; Union[List[EsriFeatureServiceBasicInfo], List, Optional[\"pd.DataFrame\"]]:\n    \"\"\"\n    Search the Grid3 data source for datasets matching a query string.\n\n    This method searches for datasets whose names contain the specified query string.\n    It can return the search results as a list of `EsriFeatureServiceBasicInfo`\n    objects or as a pandas DataFrame, depending on the `dataframe` parameter.\n\n    Args:\n        query (str): The query string to search for in the dataset names.\n        dataframe (bool): If True, returns the search results as a pandas DataFrame.\n                          If False, returns a list of `EsriFeatureServiceBasicInfo` objects.\n\n    Returns:\n        Union[List[EsriFeatureServiceBasicInfo], List, Optional[\"pd.DataFrame\"]]: A list of\n        `EsriFeatureServiceBasicInfo` objects matching the query or a pandas DataFrame of results.\n    \"\"\"\n    search_results = list(\n        filter(\n            lambda feature_server: query.upper()\n            in str(feature_server.name).upper(),\n            self.feature_services,\n        ),\n    )\n\n    total_results = len(search_results)\n    logger.info(f\"Search query for '{query}' returned {total_results} results.\")\n\n    if len(search_results) &gt; 0:\n        if dataframe:\n            pd = CheckDependencies.pandas()\n            # they don't need to see the url when rendering the dataframe.\n            data = {\n                \"id\": list(range(total_results)),\n                \"name\": [\n                    feature_service.name for feature_service in search_results\n                ],\n            }\n            return pd.DataFrame(data)\n\n        # return it as a list of dict\n        return [x.__dict__ for x in search_results]\n    print(\n        f\"Search query for '{query}' did not match any available datasets. Try another query or use `Grid3().list_data()` to see available datasets.\"\n    )\n    return []\n</code></pre>"},{"location":"api/utils/enums/","title":"Nigeria State Names","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration for Nigerian states and the Federal Capital Territory (FCT).</p> <p>This class defines all the states and the Federal Capital Territory (FCT) in Nigeria. Each value corresponds to the official name of the state or territory.</p> Source code in <code>nigeria_geodata/utils/enums.py</code> <pre><code>class NigeriaState(Enum):\n    \"\"\"\n    Enumeration for Nigerian states and the Federal Capital Territory (FCT).\n\n    This class defines all the states and the Federal Capital Territory (FCT) in Nigeria.\n    Each value corresponds to the official name of the state or territory.\n    \"\"\"\n\n    ABIA = \"Abia\"\n    ADAMAWA = \"Adamawa\"\n    AKWA_IBOM = \"Akwa Ibom\"\n    ANAMBRA = \"Anambra\"\n    BAUCHI = \"Bauchi\"\n    BAYELSA = \"Bayelsa\"\n    BENUE = \"Benue\"\n    BORNO = \"Borno\"\n    CROSS_RIVER = \"Cross River\"\n    DELTA = \"Delta\"\n    EBONYI = \"Ebonyi\"\n    EDO = \"Edo\"\n    EKITI = \"Ekiti\"\n    ENUGU = \"Enugu\"\n    GOMBE = \"Gombe\"\n    IMO = \"Imo\"\n    JIGAWA = \"Jigawa\"\n    KADUNA = \"Kaduna\"\n    KANO = \"Kano\"\n    KATSINA = \"Katsina\"\n    KEBBI = \"Kebbi\"\n    KOGI = \"Kogi\"\n    KWARA = \"Kwara\"\n    LAGOS = \"Lagos\"\n    NASARAWA = \"Nasarawa\"\n    NIGER = \"Niger\"\n    OGUN = \"Ogun\"\n    ONDO = \"Ondo\"\n    OSUN = \"Osun\"\n    OYO = \"Oyo\"\n    PLATEAU = \"Plateau\"\n    RIVERS = \"Rivers\"\n    SOKOTO = \"Sokoto\"\n    TARABA = \"Taraba\"\n    YOBE = \"Yobe\"\n    ZAMFARA = \"Zamfara\"\n    FCT = \"Abuja\"  # Abuja is the name used in the data, but the user must provide FCT\n</code></pre>"},{"location":"api/utils/exceptions/","title":"Exceptions","text":"<p>Exceptions for the nigeria_geodata Package</p> <p>This module defines custom exceptions used within the <code>nigeria_geodata</code> package. These exceptions provide more specific error handling for various failure scenarios that can occur during operations related to geospatial data processing and interactions.</p> Authors <p>Emmanuel Jolaiya Samuel Adedoyin</p> Date <p>24/08/2024</p> <p>Raises:</p> Type Description <code>NigeriaGeodataError</code> <p>Base exception for all exceptions in the nigeria_geodata package.</p> <code>RequestError</code> <p>Raised for errors encountered during HTTP requests.</p> <code>HTTPStatusError</code> <p>Raised for HTTP status-related errors.</p> <code>JSONDecodeError</code> <p>Raised for errors encountered while decoding JSON data.</p> <code>PackageNotFoundError</code> <p>Raised when a required package is not found.</p>"},{"location":"api/utils/exceptions/#nigeria_geodata.utils.exceptions.HTTPStatusError","title":"<code>HTTPStatusError</code>","text":"<p>               Bases: <code>NigeriaGeodataError</code></p> <p>Exception raised for HTTP status errors.</p> <p>This exception is used when the server returns an HTTP status code that indicates an error (e.g., 4xx or 5xx codes). It helps to differentiate between successful and unsuccessful HTTP responses.</p> Source code in <code>nigeria_geodata/utils/exceptions.py</code> <pre><code>class HTTPStatusError(NigeriaGeodataError):\n    \"\"\"Exception raised for HTTP status errors.\n\n    This exception is used when the server returns an HTTP status code that indicates\n    an error (e.g., 4xx or 5xx codes). It helps to differentiate between successful\n    and unsuccessful HTTP responses.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/utils/exceptions/#nigeria_geodata.utils.exceptions.JSONDecodeError","title":"<code>JSONDecodeError</code>","text":"<p>               Bases: <code>NigeriaGeodataError</code></p> <p>Exception raised for JSON decoding errors.</p> <p>This exception is raised when there are issues decoding JSON data. It may be caused by malformed JSON, unexpected data formats, or other issues related to JSON processing.</p> Source code in <code>nigeria_geodata/utils/exceptions.py</code> <pre><code>class JSONDecodeError(NigeriaGeodataError):\n    \"\"\"Exception raised for JSON decoding errors.\n\n    This exception is raised when there are issues decoding JSON data. It may be caused\n    by malformed JSON, unexpected data formats, or other issues related to JSON processing.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/utils/exceptions/#nigeria_geodata.utils.exceptions.NigeriaGeodataError","title":"<code>NigeriaGeodataError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all nigeria_geodata errors.</p> Source code in <code>nigeria_geodata/utils/exceptions.py</code> <pre><code>class NigeriaGeodataError(Exception):\n    \"\"\"Base exception for all nigeria_geodata errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/utils/exceptions/#nigeria_geodata.utils.exceptions.PackageNotFoundError","title":"<code>PackageNotFoundError</code>","text":"<p>               Bases: <code>ModuleNotFoundError</code></p> <p>Exception raised when required packages are not found.</p> <p>This exception is raised when a required third-party package or module is not found or not installed. It helps in identifying and handling missing dependencies.</p> Source code in <code>nigeria_geodata/utils/exceptions.py</code> <pre><code>class PackageNotFoundError(ModuleNotFoundError):\n    \"\"\"Exception raised when required packages are not found.\n\n    This exception is raised when a required third-party package or module is not found\n    or not installed. It helps in identifying and handling missing dependencies.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/utils/exceptions/#nigeria_geodata.utils.exceptions.RequestError","title":"<code>RequestError</code>","text":"<p>               Bases: <code>NigeriaGeodataError</code></p> <p>Exception raised for errors during the request.</p> <p>This exception is used to indicate problems that occur during the process of making requests to data sources. It may be raised due to network issues, invalid request parameters, or other request-related failures.</p> Source code in <code>nigeria_geodata/utils/exceptions.py</code> <pre><code>class RequestError(NigeriaGeodataError):\n    \"\"\"Exception raised for errors during the request.\n\n    This exception is used to indicate problems that occur during the process\n    of making requests to data sources. It may be raised due to network issues,\n    invalid request parameters, or other request-related failures.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/utils/logging/","title":"Logging","text":"<p>Logging Configuration Module</p> <p>This module provides a centralized logging configuration for the nigeria_geodata package. It sets up a logger with a default warning level and a console handler to format and display log messages.</p> Authors <p>Emmanuel Jolaiya Samuel Adedoyin</p> Date <p>24/08/2024</p> <p>The logger is configured to output messages to the console with the following format: \"nigeria_geodata:%(asctime)s - %(name)s - %(levelname)s - %(message)s\"</p> <p>Functions: - configure_logging: Allows for customization of the logging level.</p> Usage <p>To use the logging configuration, import this module and call the <code>configure_logging</code> function to adjust the logging level as needed. The logger will automatically use the configured level and format for log messages.</p> <p>Example:     from nigeria_geodata.utils import configure_logging</p> <pre><code># Set the logging level to DEBUG\nlogger_module.configure_logging(logging.DEBUG)\n</code></pre>"},{"location":"api/utils/logging/#nigeria_geodata.utils.logger.configure_logging","title":"<code>configure_logging(level=logging.WARNING)</code>","text":"<p>Configure the logging level for the package.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Logging level (e.g., logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR)</p> <code>WARNING</code> Example Source code in <code>nigeria_geodata/utils/logger.py</code> <pre><code>def configure_logging(level=logging.WARNING):\n    \"\"\"\n    Configure the logging level for the package.\n\n    Args:\n        level (int): Logging level (e.g., logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR)\n\n    Example:\n        # Set logging level to INFO\n        configure_logging(logging.INFO)\n    \"\"\"\n    logger.setLevel(level)\n    for handler in logger.handlers:\n        handler.setLevel(level)\n</code></pre>"},{"location":"api/utils/logging/#nigeria_geodata.utils.logger.configure_logging--set-logging-level-to-info","title":"Set logging level to INFO","text":"<p>configure_logging(logging.INFO)</p>"}]}